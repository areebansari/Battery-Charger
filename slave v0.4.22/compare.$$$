Comparing D:\Dropbox\AEI Work\HMI Battery Charger (Muhib)\Rev-0\03 - Software Section\version 0.4\slave\slave v0.4.22\slave v0.4.22.c and D:\Dropbox\AEI Work\HMI Battery Charger (Muhib)\Rev-0\03 - Software Section\version 0.4\slave\slave v0.4.21\slave v0.4.21.c
D <! /*******************************************************************************
D <! **    Version : 0.4.22                                                        **
D <! **    Date : 13-Oct-2014                                                      **
D <! **    Author : Muhib Raza (muhibraza@hotmail.com)                             **
D <! **    Project : Programmable Thyristor Controlled Battery Charger             **
D <! **    Designed for : Advance Electronics International Co.                    **
D <! **    Brief : Code for Slave CPU PIC18F4520 (HMI Circuit)                     **
D <! **                                                                            **
D <! ** ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ **
D <! **   Pin assignment :                                                         **
D <! **       PIN_A1 ->  Strobe Pin for LCD (OUT)                                  **
D <! **       PIN_A2 ->  Clock Pin for LCD (OUT)                                   **
D <! **       PIN_A3 ->  Data Pin for LCD (OUT)                                    **
D <! **       PIN_B0 ->  Switch1 (IN)                                              **
D <! **       PIN_B1 ->  Switch2 (IN)                                              **
D <! **       PIN_B2 ->  Switch3 (IN)                                              **
D <! **       PIN_B3 ->  Switch4 (IN)                                              **
D <! **       PIN_C0 ->  LED1 (OUT)                                                **
D <! **       PIN_C1 ->  LED2 (OUT)                                                **
D <! **       PIN_C3 ->  Used as SCL for I2C communication                         **
D <! **       PIN_C4 ->  Used as SDA for I2C communication                         **
D <! **       PIN_C5 ->  Driver Enable [DE] (OUT)                                  **
D <! **       PIN_C6 ->  MODBBUS/RS232 Tx (OUT)                                    **
D <! **       PIN_C7 ->  MODBBUS/RS232 Rx (OUT)                                    **
D <! **       PIN_D0 ->  LED3 (OUT)                                                **
D <! **       PIN_D1 ->  LED4 (OUT)                                                **
D <! **       PIN_D2 ->  LED5 (OUT)                                                **
D <! **       PIN_D3 ->  LED6 (OUT)                                                **
D <! **       PIN_D4 ->  LED7 (OUT)                                                **
D <! **       PIN_D5 ->  LED8 (OUT)                                                **
D <! **       PIN_D6 ->  LED9 (OUT)                                                **
D <! **       PIN_D7 ->  LED10 (OUT)                                               **
D <! **                                                                            **
D <! **   EEPROM Location Map :                                                    **
D <! **       Location 0 : e_flag (for checking first run after being programmed)  **
D <! **       Location 1 : voltage setpoint (low byte)                             **
D <! **       Location 2 : voltage setpoint (high byte)                            **
D <! **       Location 3 : current setpoint (low byte)                             **
D <! **       Location 4 : current setpoint (high byte)                            **
D <! **       Location 5 : Parameter 3 (low byte)                                  **
D <! **       Location 6 : Parameter 3 (high byte)                                 **
D <! **       Location 7 : Parameter 4 (low byte)                                  **
D <! **       Location 8 : Parameter 4 (high byte)                                 **
D <! **       Location 9 : Parameter 5 (low byte)                                  **
D <! **       Location 10 : Parameter 5 (high byte)                                **
D <! **                                                                            **
D <! **   Interrupt -> Associated Function :                                       **
D <! **       INT_TIMER3 -> void timer_3_isr(void)                                 **
D <! **       INT_SSP    -> void SSP_isr(void)                                     **
D <! **                                                                            **
D <! **   Function Description :                                                   **
D <! **       [+] int f(int k) - Function that returns location for EEPROM         **
D <! **                          read/write                                        **
D <! **       [+] void edit_value(long lcdval) - Function for editing parameters   **
D <! **       [+] void lcd_print(int data) - Function for printing data on LCD     **
D <! **       [+] void lcd_out(int n,long val) - Function for LCD data arrangement **
D <! **       [+] void lcd_flash(short k,long lcd_value) - Function for flashing LCD*
D <! **       [+] void led_on(int led) - Function for turning on specific LED      **
D <! **       [+] void led_off(int led) - Function for turning off specific LED    **
D <! **       [+] void all_leds_off() - Function for turning off all LEDs          **
D <! **                                                                            **
D <! **       [#] SSP_isr() - ISR for I2C communication                            **
D <! **       [#] timer_3_isr() - ISR for timer3, used for generating fixed        **
D <! **                           interrupts at a rate of 90ms                     **
D <! *******************************************************************************/
I !> #include <hardwaredefinitions.h>	// File that holds hardware definitions
I !> #include <functions.c>			// File that holds functions for LCD and LED
I !> #USE I2C(SLAVE,SDA=PIN_C4, SCL=PIN_C3,ADDRESS=0xA0)	// use I2C with device address 0xA0
I !> #define max_voltage	30		// maximum voltage to which editing of voltage set point is limited
I !> #define min_voltage	0 		// minimum voltage to which editing of voltage set point is limited
I !> #define max_current_in_mA	960	// maximum value of current to which editing of voltage set point is limited
I !> #define min_current_in_mA	0		// minimum value of current to which editing of voltage set point is limited
I !> #define initial_setpoint_for_voltage 13.2	// initial voltage setpoint that is effective when program executed first time
I !> #define initial_current_limit_in_mA 500	// initial current limit that is effective when program executed first time
  
D <! /* INCLUDES & OTHER PREPROCESSORS --------------------------------------------*/
D <! #include "hardwaredefinitions.h"   // File that holds hardware definitions
D <! #include "functions.c"         // File that holds functions for LCD and LED
D <! #USE I2C(SLAVE,SDA=PIN_C4, SCL=PIN_C3,ADDRESS=0xA0)
D <! 
D <! /* DEFINES -------------------------------------------------------------------*/
D <! /* Maximum voltage to which editing of voltage set point is limited */
D <! #define max_voltage   30
D <! 
D <! /* Minimum voltage to which editing of voltage set point is limited */
D <! #define min_voltage   0
D <! 
D <! /* maximum value of current to which editing of voltage set point is limited */
D <! #define max_current_in_mA   960
D <! 
D <! /* Minimum value of current to which editing of voltage set point is limited */
D <! #define min_current_in_mA   0
D <! 
D <! /* Initial voltage setpoint that is effective when program executed first time*/
D <! #define initial_setpoint_for_voltage 13.2
D <! 
D <! /* Initial current limit that is effective when program executed first time */
D <! #define initial_current_limit_in_mA 500
D <! 
D <! /* GLOBAL VARIABLES ----------------------------------------------------------*/
D <! int1 show_parameters_mode=0, edit_parameters_mode=FALSE, flash=FALSE;
D <! int state=0 , e_flag=0, address, a, low_byte, high_byte, delay_time=125;
I !> //************************* Initialization *************************//
I !> int state=0 , address;
I !> int data[500];
I !> int reading[128];
I !> int1 show_parameters_mode=0; int e_flag=0; int1 edit_parameters_mode=FALSE; int1 flash=FALSE;
I !> int a, low_byte, high_byte;
I !> long value[5];
  int edit_counter=0, flash_counter=0, menu_timeout_monitor=0;
D <! int data[500], reading[128];
D <! long loop_execution_counter=0;
D <! long value[5];
D <! long max_setpoint_vo=max_voltage*10;
I !> long max_setpoint_vo=max_voltage*10;	// multiplication by 10 for avoiding decimal point in calculations
  long min_setpoint_vo=min_voltage*10;
  long max_current_limit=max_current_in_mA*10;
  long min_current_limit=min_current_in_mA*10;
I !> long loop_execution_counter=0;
I !> int delay_time=125;
I !> //******************************************************************//
  
D <! /*============================================================================*/
D <! /***
D <! * Function      : void SSP_isr(void)
D <! * Parameters    : None
D <! * Return value  : None
D <! * Purpose       : Sends/Receives Data to/from master CPU
D <! ***/
D <! /*============================================================================*/
I !> //************************* Interrupt routine for I2C communication *************************//
  #INT_SSP
D <! void SSP_isr(void)
D <! {
D <! state = i2c_isr_state();
I !> void SSP_isr()
I !> {     state = i2c_isr_state();
  if (state < 128)
  {
D <! /* If device address matched, then receive data from master */
D <! if(state==0) address=i2c_read();
I !> if (state == 0)                         // Device Address Match Received From Master
I !> address = i2c_read ();
  
D <! else if (state >= 1 && state < 128)
D <! reading[state-1] = i2c_read();  // Store Data in array one by one
I !> else if (state >= 1 && state < 128)    // Receive Data From Master
I !> reading[state-1] = i2c_read ();           // Store Data in array one by one
  }
  
D <! else if (state >= 128)  // If Master is requesting Data
I !> else if (state >= 128)                 // Master is requesting Data
  i2c_write (data[state - 127]);       // Send Data to Master
I !> 
  }
I !> //*******************************************************************************************//
  
D <! /*============================================================================*/
D <! /***
D <! * Function      : void timer_3_isr(void)
D <! * Parameters    : None
D <! * Return value  : None
D <! * Purpose       : Used for timeouts and flashing purposes
D <! ***/
D <! /*============================================================================*/
D <! #INT_TIMER3
I !> //*********************************** Interrupt routine for timer 3 *************************************//
I !> #INT_TIMER3				// timer 3 is used for timeout and flashing purposes
  void timer_3_isr(void)
  {
  if (show_parameters_mode==TRUE && edit_parameters_mode==TRUE) edit_counter++;
  // edit_counter increments every 90 ms when in edit mode
D <! 
  else if (show_parameters_mode==TRUE) menu_timeout_monitor++;
  // menu timeout counter increments every 90 ms when in menu stage 0
I !> 
I !> flash_counter++;  		// flash_counter increments every 90 ms
I !> if (flash_counter==3) { flash=~flash; flash_counter=0;}  // if 90ms*3= 270 ms have passed, then complement flag
I !> 
I !> set_timer3(9286);		// timer 3 generates interrupts every 90 ms
I !> }
  
D <! flash_counter++;     // flash_counter increments every 90 ms
  
D <! if (flash_counter==3) // if 90ms*3= 270 ms have passed, then complement flag
D <! { flash=~flash; flash_counter=0;}
I !> //*******************************************************************************************//
  
D <! set_timer3(9286);      // set timer 3 to generate interrupt every 90 ms
D <! }
  
D <! /*============================================================================*/
D <! /***
D <! * Function      : int f(int k)
D <! * Parameters    : int k
D <! * Return value  : int
D <! * Purpose       : Returns location for EEPROM read and write
D <! ***/
D <! /*============================================================================*/
I !> //************** Function that returns location for EEPROM read and write **************//
  int f(int k)
  {
D <! return (k*2)+1;
I !> return (k*2)+1;	// for k=0 , it returns 1 ; for k=1, it returns 3 ; for k=2 it returns 5 and so on
  }
I !> //*************************************************************************************//
  
D <! /*============================================================================*/
D <! /***
D <! * Function      : void edit_value(long lcdval)
D <! * Parameters    : long lcdval
D <! * Return value  : none
D <! * Purpose       : Edits parameter values
D <! ***/
D <! /*============================================================================*/
D <! void edit_value(long lcdval)
I !> //*************************** Function that edits parameter value  ***************************//
I !> void edit_value(long lcdval)  // receives copy of displayed value that needs to be edited
  {
D <! led_on(3);       // LED 3 is on for indication of menu stage 1 (or edit mode)
I !> led_on(3); 		// LED 3 is on for indication of menu stage 1 (or edit mode)
  edit_parameters_mode=TRUE;   // Flag to indicate edit mode
  
  do
  {
D <! /* call function for flashing LCD with lcdval every 270 ms */
D <! lcd_flash(flash,lcdval);
I !> lcd_flash(flash,lcdval);	// call function from function.c file for flashing LCD with lcdval every 270 ms
  
  while(!input(SW2))
  {
D <! delay_ms(delay_time);  /* delay for debouncing. Also used for fast
D <! *  increment/decrement */
D <! edit_counter=0; /* reset edit counter on button press so that
D <! * timeout does not occur */
D <! loop_execution_counter++;   // increment on every execution
D <! 
D <! /* a is the pointer for parameter value.
D <! * if a is 0 then parameter 1 is selected */
D <! if (a==0)
I !> delay_ms(delay_time);	// delay for debouncing. also used for fast increment/decrement
I !> edit_counter=0;			// reset edit counter on button press so that timeout does not occur
I !> loop_execution_counter++;	// increment every time the loop is executed
I !> if (a==0)		// a is the pointer for parameter value. if a is 0 then parameter 1 is selected
  {
D <! /* Parameter 1 is setpoint voltage.
D <! * No increment if max value reached */
D <! if(lcdval==max_setpoint_vo) break;
D <! 
D <! lcdval++;   /* Increment one value if within limits.
D <! * decimal point in LCD shows 0.1 Volt increment */
I !> if(lcdval==max_setpoint_vo) break; // parameter 1 is setpoint voltage. dont increment if maximum value reached
I !> lcdval++;	// increment one value if already within limits. decimal point in LCD will show 0.1 Volt increment
  }
  
D <! else if (a==1)   // if a is 1 then parameter 2 is selected
I !> else if (a==1)	// if a is 1 then parameter 2 is selected
  {
D <! /* parameter 2 is max current limit.
D <! * No increment if maximum value reached */
D <! if(lcdval==max_current_limit) break;
D <! 
I !> if(lcdval==max_current_limit) break;	// parameter 2 is max current limit. dont increment if maximum value reached
I !> //!            	else if ((loop_execution_counter<32) || (lcdval>=(max_current_limit-100)))	lcdval+=10;
I !> //!	            else lcdval+=100;
  if(loop_execution_counter>=32) delay_time=10;
D <! /* change debouncing delay from 125 to 10 if button has been
D <! * pressed for 4 sec.
D <! * 125 ms * 32 = 4 sec  */
D <! 
D <! lcdval+=10; /* Increment 10 values if within limits.
D <! * decimal point in LCD will show 1 mA increment */
I !> // change debouncing delay from 125 to 10 if button has been pressed for 4 sec.
I !> // 125 ms * 32 = 4 sec
I !> lcdval+=10; // increment 10 values if within limits. decimal point in LCD will show 1 mA increment
I !> }
I !> lcd_out(2,lcdval);	// display the final value on LCD2
I !> value[a]=lcdval;		// value array used for storing 5 parameters against respective pointer a
I !> low_byte=value[a]; 	// separate low byte of int16 data
I !> high_byte=value[a]>>8;	// shift right and separate high byte
I !> data[f(a)]=low_byte;		// store low byte in data array on location 1 when pointer a=0
I !> data[f(a)+1]=high_byte; // store high byte in data array on location 2 when pointer a=0
I !> // data array will be accessed by Master PC through Interrupt service routine
I !> // the master controller reads edited parameter values after every 1 second
I !> // the data array needs to be updated every time there is a change in parameters
  }
D <! lcd_out(2,lcdval);   // display the final value on LCD2
I !> loop_execution_counter=0;		// reset count for how many times the loop has been executed
I !> delay_time=125;					// reset delay time for debouncing
  
D <! /* value array used for storing 5 parameters against respective
D <! * pointer a */
D <! value[a]=lcdval;
D <! low_byte=value[a];    // separate low byte of int16 data
D <! high_byte=value[a]>>8;   // shift right and separate high byte
D <! 
D <! // store low byte in data array on location 1 when pointer a=0
D <! data[f(a)]=low_byte;
D <! 
D <! // store high byte in data array on location 2 when pointer a=0
D <! data[f(a)+1]=high_byte;
D <! 
D <! /* Data array will be accessed by Master PC through ISR. The
D <! * master controller reads edited parameter values after every
D <! * second. The data array needs to be updated every time there is
D <! 
I !> while(!input(SW3))			// this loop is for decrement. procedure is same as increment loop
I !> {
I !> delay_ms(delay_time);
I !> edit_counter=0;
I !> loop_execution_counter++;
I !> if (a==0)
  {
  if(lcdval==min_setpoint_vo) break;
  lcdval--;
  }
  else if (a==1)
  {
  if(lcdval==min_current_limit) break;
I !> //!					else if ((loop_execution_counter<32) || (lcdval<=(min_current_limit+100)) )	lcdval-=10;
I !> //!	            else lcdval-=100;
  if(loop_execution_counter>=32) delay_time=10;
  lcdval-=10;
  }
  lcd_out(2,lcdval);
  value[a]=lcdval;
  low_byte=value[a];
  high_byte=value[a]>>8;
  data[f(a)]=low_byte;
  data[f(a)+1]=high_byte;
  }
  loop_execution_counter=0;
  delay_time=125;
  
D <! // if no editing is done for 56 * 90 ms = 5.04 second, then break
D <! if (edit_counter==56) break;
D <! }while(input(SW1));      // exit from loop when switch 1 is pressed
D <! 
D <! delay_ms(50);            // Delay for debouncing
D <! while(!input(SW1));      // halt here if bounce still exists
D <! 
D <! edit_counter=0;           // reset edit counter
D <! 
D <! /* clear flag to indicate an exit from "edit parameters mode" */
D <! edit_parameters_mode=FALSE;
D <! led_off(3);               // turn off indication LED3
I !> if (edit_counter==56) break;	// if no editing is done for 56 * 90 ms = 5.04 second, then break from edit mode
I !> }while(input(SW1));		// exit from loop when switch 1 is pressed
I !> delay_ms(50);				// Delay for debouncing
I !> while(!input(SW1));		// halt here if bounce still exists
I !> edit_counter=0;  			// reset edit counter
I !> edit_parameters_mode=FALSE;  		// clear flag to indicate an exit from menu stage 1 or "edit parameters mode"
I !> led_off(3);					// turn off indication
  }
I !> /**********************************************************************************************/
  
D <! /*============================================================================*/
D <! /***
D <! * Function     : void main(void)
D <! * Parameters   : None
D <! * Return value : None
D <! * Purpose      : Serves for the following purposes:
D <! *                [+] Displays voltage and current values on LCDs
D <! *                [+] Scans menu button SW4 and calls edit function if pressed
D <! *                [+] Reads/writes values to EEPROM
D <! *                [+] Loops forever
D <! ***/
D <! /*============================================================================*/
I !> /************************************* Main Function **************************************/
  void main(void)
  {
  output_high(STROBE_PIN);   // De-activate the strobe pin
D <! output_high(CLOCK_PIN);      // De-activate the clock pin
D <! all_leds_off();            // Make all LEDs off initially
I !> output_high(CLOCK_PIN);   	// De-activate the clock pin
I !> all_leds_off();				// Make all LEDs off initially
  
D <! enable_interrupts(INT_SSP);   // Enable Interrupt for SPI or I2C activity
D <! setup_timer_3 (T3_INTERNAL | T3_DIV_BY_8); //16-Bit Timer;1.6 usec for 1 tick
D <! enable_interrupts(GLOBAL);      // Enable global interrupts
I !> enable_interrupts(INT_SSP);	// Enable Interrupt for SPI or I2C activity
I !> setup_timer_3 (T3_INTERNAL | T3_DIV_BY_8);  	// 16-Bit Timer, 1.6 usec for one tick
I !> enable_interrupts(GLOBAL);		// Enable global interrupts
  
D <! // long variable to hold values to be shown on LCD 1 and LCD 2
D <! long lcd_1_val, lcd_2_val;
D <! 
D <! /* long variables that hold values of voltage and current received from
D <! * master controller */
D <! long voltage, current;
D <! long temp_val;     // temporary LCD value that is going to be edited by user
D <! 
D <! /* variables that hold high and low values of parameters */
D <! long high_val, low_val;
D <! 
D <! // menu array with five menu numbers from 1 till 5, decimal point is in LCD
D <! int menu[5]={10,20,30,40,50};
I !> long lcd_1_val, lcd_2_val; // long variable to hold values to be shown on LCD 1 and LCD 2
I !> long voltage, current;		// long variables that hold values of voltage and current received from master controller
I !> long temp_val;		// temporary LCD value that is going to be edited by user
I !> long high_val, low_val;	// variables that hold high and low values of parameters
I !> int menu[5]={10,20,30,40,50};	// menu array with five menu numbers from 1 till 5, decimal point is in LCD
  reading[0]=0xB8;
  reading[2]=0xB8;
  reading[1]=0x22;
D <! reading[3]=0x22;
D <! /* These four lines are for displaying 8888 on both LCDs when no data has
D <! * been received from Master controller */
I !> reading[3]=0x22;	// These four lines are for displaying 8888 on both LCDs when no data has been received from Master controller
I !> e_flag=read_eeprom(0);		// Flag to hold value of first location of EEPROM after being programmed
I !> // the internal EEPROM hold 0xFF value in all locations initially
  
D <! 
D <! e_flag=read_eeprom(0);
D <! /* Flag to hold value of first location of EEPROM after being programmed
D <! * the internal EEPROM hold 0xFF value in all locations initially */
D <! 
D <! /* Write arbitrary values into EEPROM if Started for the first time
D <! * if e_flag holds a non-zero value then execute the following commands */
D <! if (e_flag)
I !> //******* Write arbitrary values into EEPROM if Started for the first time *******//
I !> if (e_flag)		// if e_flag holds a non-zero value then execute the following commands
  {
D <! e_flag=0;   // make the e_flag=0
I !> e_flag=0;	// make the e_flag=0
  write_eeprom(0,e_flag); // store 0 in location 0 of EEPROM
I !> value[0]=initial_setpoint_for_voltage*10;	// voltage set_point multiplied by 10 and stored as parameter 1
I !> value[1]=initial_current_limit_in_mA*10;	// max current limit multiplied by 10 and stored as parameter 2
I !> value[2]=2500;		// arbitrary value for parameter 3
I !> value[3]=3500;		// arbitrary value for parameter 4
I !> value[4]=6500;		// arbitrary value for parameter 5
  
D <! // voltage set_point multiplied by 10 and stored as parameter 1
D <! value[0]=initial_setpoint_for_voltage*10;
D <! 
D <! // max current limit multiplied by 10 and stored as parameter 2
D <! value[1]=initial_current_limit_in_mA*10;
D <! 
D <! value[2]=2500;      // arbitrary value for parameter 3
D <! value[3]=3500;      // arbitrary value for parameter 4
D <! value[4]=6500;      // arbitrary value for parameter 5
D <! 
D <! // copy the initial values into EEPROM on respective locations
D <! for (a=0 ; a<=4 ; a++)
I !> for (a=0 ; a<=4 ; a++)	// copy the arbitrary and initial values into EEPROM on respective locations
  {
D <! // copy low byte of value array for respective pointer
D <! low_byte=value[a];
D <! 
D <! // copy high byte of value array for respective pointer
D <! high_byte=value[a]>>8;
D <! 
D <! //store low byte in EEPROM on location determined by f(a)
D <! write_eeprom(f(a),low_byte);
D <! 
D <! //store high byte in EEPROM just one location above f(a)
D <! write_eeprom(f(a)+1,high_byte);
I !> low_byte=value[a];	// copy low byte of value array for respective pointer
I !> high_byte=value[a]>>8;	// copy high byte of value array for respective pointer
I !> write_eeprom(f(a),low_byte);	//store low byte in EEPROM on location determined by f(a)
I !> write_eeprom(f(a)+1,high_byte); //store high byte in EEPROM just one location above f(a)
  }
  }
  
D <! /* Read the 5 parameter values from EEPROM into array */
D <! // copy the values from EEPROM into data array that would be sent to master
D <! for (a=0 ; a<5 ; a++)
D <! {
D <! // copy low byte from EEPROM for every respective pointer
D <! data[f(a)]=read_eeprom(f(a));
I !> //************** Read the 5 parameter values from EEPROM into array **************//
  
D <! // copy high byte from EEPROM for every respective pointer
D <! data[f(a)+1]=read_eeprom(f(a)+1);
D <! 
D <! low_val=read_eeprom(f(a));      // copy low byte into 16 bit variable
D <! high_val=read_eeprom(f(a)+1); // copy high byte into 16 bit variable
I !> for (a=0 ; a<5 ; a++)		// copy the values from EEPROM into data array that would be sent to master
I !> {  data[f(a)]=read_eeprom(f(a));	// copy low byte from EEPROM for every respective pointer
I !> data[f(a)+1]=read_eeprom(f(a)+1); // copy high byte from EEPROM for every respective pointer
I !> low_val=read_eeprom(f(a));		// copy low byte value into 16 bit variable
I !> high_val=read_eeprom(f(a)+1); // copy high byte value into 16 bit variable
  high_val=high_val<<8;   // shift high value to left 8 times
D <! value[a]=high_val | low_val;
D <! // concatenate high and low bytes and store 16 bit variable in array
I !> value[a]=high_val | low_val;	// concatenate high and low bytes and store 16 bit variable in array
  }
  
D <! a=0; // variable a is used as pointer for array elements in the whole program
I !> a=0;		// variable a is used as a pointer for array elements in the whole program
  
  //********************** Main Loop that repeats forever **********************//
  do
  {
  /* Following 4 lines read and display the voltage and current reading
  that is received from master CPU */
D <! // concatenate lower and higher bytes of voltage value
D <! voltage= make16(reading[1],reading[0]);
D <! 
D <! // concatenate lower and higher bytes of current value
D <! current= make16(reading[3],reading[2]);
D <! 
D <! lcd_1_val=voltage;   // copy voltage to lcd 1 variable
I !> voltage= make16(reading[1],reading[0]);	// concatenate lower and higher bytes of voltage value
I !> current= make16(reading[3],reading[2]);   // concatenate lower and higher bytes of current value
I !> lcd_1_val=voltage;	// copy voltage to lcd 1 variable
  lcd_2_val=current;   // copy current to lcd 2 variable
D <! while(!input(SW4))         // Press once to enter menu
D <! {  delay_ms(50);            // debouncing
D <! while(!input(SW4));      //debouncing
D <! led_on(4); // indication for menu stage 0 ("show parameter" screen)
D <! show_parameters_mode=TRUE;  //set flag when show parameter screen is shown
I !> while(!input(SW4))			// Press once to enter menu
I !> {  delay_ms(50);				// debouncing
I !> while(!input(SW4));		//debouncing
I !> led_on(4);					// indication for entering menu stage 0 (or "show parameter" screen)
I !> show_parameters_mode=TRUE;	// set flag when show parameter screen is shown
I !> clear_interrupt(INT_TIMER3);	// Clear Timer3 flag if interrupt has occured prior to being enabled
I !> enable_interrupts(INT_TIMER3);	// enable timer for timeout monitoring and screen flash in edit screen
I !> set_timer3(9286);			// set timer 3 to generate interrrupt on every 90 ms
I !> lcd_1_val=menu[a];		// hold parameter number for LCD1
I !> lcd_2_val=value[a];		// hold corresponding parameter value for LCD2
I !> lcd_out(1,lcd_1_val);	// display lcd 1 value on LCD1
I !> lcd_out(2,lcd_2_val);	// display lcd 2 value on LCD2
I !> menu_timeout_monitor=0;	// reset timeout monitor because SW4 has been pressed
  
D <! // Clear Timer3 flag if interrupt has occured prior to being enabled
D <! clear_interrupt(INT_TIMER3);
D <! enable_interrupts(INT_TIMER3);
D <! // enable timer for timeout monitoring and screen flash in edit screen
D <! 
D <! set_timer3(9286);    // set timer 3 to generate interrupt on every 90 ms
D <! lcd_1_val=menu[a];      // hold parameter number for LCD1
D <! lcd_2_val=value[a];      // hold corresponding parameter value for LCD2
D <! lcd_out(1,lcd_1_val);   // display lcd 1 value on LCD1
D <! lcd_out(2,lcd_2_val);   // display lcd 2 value on LCD2
D <! menu_timeout_monitor=0;  // reset timeout monitor
D <! 
D <! /* Select the parameter number to be shown through SW3 and SW2 */
I !> //************* Select the parameter number to be shown through SW3 and SW2 *************//
  do
  {
D <! while(!input(SW3))      // Press once to decrement parameter number
I !> while(!input(SW3))		// Press once to decrement parameter number
  {
D <! while(!input(SW3));   // halt here until button is released
D <! delay_ms(50);         // delay to cater for bounce
D <! menu_timeout_monitor=0;      // reset tiemout monitor
D <! if (a==0) a=4;      // underflow if a is already 0
D <! else a--;         // otherwise decrement once in a
I !> while(!input(SW3));	// halt here until button is released
I !> delay_ms(50);			// delay to cater for bounce
I !> menu_timeout_monitor=0;		// reset tiemout monitor
I !> if (a==0) a=4;		// underflow if a is already 0
I !> else a--;			// otherwise decrement once in a
  }
  
D <! while(!input(SW2))      // Press once to increment parameter number
I !> while(!input(SW2))		// Press once to increment parameter number
  {
  while(!input(SW2));
  delay_ms(50);
  menu_timeout_monitor=0;
D <! if (a==4) a=0;      // overflow if a is already 0
D <! else a++;         // otherwise increment once in a
I !> if (a==4) a=0;		// overflow if a is already 0
I !> else a++;			// otherwise increment once in a
  }
  
  lcd_1_val=menu[a];
  lcd_2_val=value[a];
D <! lcd_out(1,lcd_1_val);      // Show updated parameter number
D <! lcd_out(2,lcd_2_val);      // Show corresponding value on other LCD
I !> lcd_out(1,lcd_1_val);		// Show updated parameter number
I !> lcd_out(2,lcd_2_val);		// Show corresponding value on other LCD
I !> 
I !> //**** Press SW4 to edit the parameter Value and also store in EEPROM and send to Master CPU ****//
  
D <! /* Press SW4 to edit the parameter Value; store in EEPROM; send to Master CPU */
  while(!input(SW4))
  {
  while(!input(SW4));
D <! menu_timeout_monitor=0;   // reset timeout monitor
D <! temp_val=lcd_2_val;      // copy LCD 2 value in temporary variable.
D <! edit_value(temp_val);
D <! // pass copy of temporary variable in edit value function
I !> menu_timeout_monitor=0;	// reset timeout monitor because SW4 has been pressed
I !> temp_val=lcd_2_val;		// copy LCD 2 value in temporary variable.
I !> edit_value(temp_val);	// pass copy of temporary variable in edit value function
I !> write_eeprom(f(a),low_byte);	// store low byte on respective location in EEPROM after returning from edit function
I !> write_eeprom(f(a)+1,high_byte); // store high byte on respective location in EEPROM after returning from edit function
I !> }
I !> /************************************************************************************************/
  
D <! write_eeprom(f(a),low_byte);
D <! /* store low byte on respective location in EEPROM after
D <! * returning from edit function */
D <! 
D <! write_eeprom(f(a)+1,high_byte);
D <! /* store high byte on respective location in EEPROM after
D <! * returning from edit function */
D <! } // while(!input(SW4))
D <! 
D <! if(menu_timeout_monitor==56) break;
D <! // if no button is pressed for 5.04 seconds then menu timeout will occur
D <! 
D <! } while(input(SW1));      // Press once to exit from menu
I !> if(menu_timeout_monitor==56) break;	// if no button is pressed for 5.04 seconds then menu timeout will occur
I !> } while(input(SW1));		// Press once to exit from menu
  /******************************************************************************/
D <! disable_interrupts(INT_TIMER3);
D <! // disable timer 3. there is no need of timeout or flashing on main screen
D <! 
D <! menu_timeout_monitor=0;      // reset timeout monitor
D <! show_parameters_mode=FALSE;   // clear flag for show parameters mode
D <! led_off(4);
D <! // led off to indicate an exit from menu stage 0 (show parameters screen)
I !> disable_interrupts(INT_TIMER3);	// disable timer 3. there is no need of timeout or flashing on main screen
I !> menu_timeout_monitor=0;		// reset timeout monitor
I !> show_parameters_mode=FALSE;	// clear flag for show parameters mode
I !> led_off(4);		// led off to indicate an exit from menu stage 0 (show parameters screen)
  }
  /******************************************************************************/
D <! /* get back to main screen and display voltage and current values
D <! * that have been received in reading[] array from master CPU */
D <! lcd_out(1,lcd_1_val);
D <! lcd_out(2,lcd_2_val);
I !> lcd_out(1,lcd_1_val);	// get back to main screen and display voltage and current values
I !> lcd_out(2,lcd_2_val);	// that have been received in reading[] array from master CPU
I !> 
  
  }while(TRUE);
  }
D <! /****************************** END OF FILE  **********************************/
I !> /******************************************************************************************/
I !> 
