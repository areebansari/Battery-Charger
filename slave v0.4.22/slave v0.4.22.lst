CCS PCH C Compiler, Version 4.124, 62034               13-Jan-15 09:29

               Filename: D:\Dropbox\AEI Work\HMI Battery Charger (Muhib)\Rev-0\03 - Software Section\version 0.4\slave\slave v0.4.22\slave v0.4.22.lst

               ROM used: 3164 bytes (10%)
                         Largest free fragment is 28768
               RAM used: 689 (45%) at main() level
                         722 (47%) worst case
               Stack:    6 worst case (4 in main + 2 for interrupts)

*
0000:  GOTO   MAIN
*
0008:  MOVWF  04
000A:  MOVFF  STATUS,05
000E:  MOVFF  BSR,06
0012:  MOVLB  0
0014:  MOVFF  FSR0L,0C
0018:  MOVFF  FSR0H,07
001C:  MOVFF  FSR1L,08
0020:  MOVFF  FSR1H,09
0024:  MOVFF  FSR2L,0A
0028:  MOVFF  FSR2H,0B
002C:  MOVFF  PRODL,12
0030:  MOVFF  PRODH,13
0034:  MOVFF  PCLATH,14
0038:  MOVFF  TABLAT,15
003C:  MOVFF  TBLPTRL,16
0040:  MOVFF  TBLPTRH,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  PIE2.TMR3IE
0056:  GOTO   0060
005A:  BTFSC  PIR2.TMR3IF
005C:  GOTO   0152
0060:  BTFSS  PIE1.SSPIE
0062:  GOTO   006C
0066:  BTFSC  PIR1.SSPIF
0068:  GOTO   00D2
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FSR0L
0080:  MOVFF  07,FSR0H
0084:  BSF    07.7
0086:  MOVFF  08,FSR1L
008A:  MOVFF  09,FSR1H
008E:  MOVFF  0A,FSR2L
0092:  MOVFF  0B,FSR2H
0096:  MOVFF  12,PRODL
009A:  MOVFF  13,PRODH
009E:  MOVFF  14,PCLATH
00A2:  MOVFF  15,TABLAT
00A6:  MOVFF  16,TBLPTRL
00AA:  MOVFF  17,TBLPTRH
00AE:  MOVF   04,W
00B0:  MOVFF  06,BSR
00B4:  MOVFF  05,STATUS
00B8:  RETFIE 0
.................... /******************************************************************************* 
.................... **    Version : 0.4.22                                                        ** 
.................... **    Date : 10-Jan-2015                                                      ** 
.................... **    Author : Muhib Raza (muhibraza@hotmail.com)                             ** 
.................... **    Project : Programmable Thyristor Controlled Battery Charger             ** 
.................... **    Designed for : Advance Electronics International Co.                    ** 
.................... **    Brief : Code for Slave CPU PIC18F4520 (HMI Circuit)                     ** 
.................... **                                                                            ** 
.................... ** ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ** 
.................... **   Pin assignment :                                                         ** 
.................... **       PIN_A1 ->  Strobe Pin for LCD (OUT)                                  ** 
.................... **       PIN_A2 ->  Clock Pin for LCD (OUT)                                   ** 
.................... **       PIN_A3 ->  Data Pin for LCD (OUT)                                    ** 
.................... **       PIN_B0 ->  Switch1 (IN)                                              ** 
.................... **       PIN_B1 ->  Switch2 (IN)                                              ** 
.................... **       PIN_B2 ->  Switch3 (IN)                                              ** 
.................... **       PIN_B3 ->  Switch4 (IN)                                              ** 
.................... **       PIN_C0 ->  LED1 (OUT)                                                ** 
.................... **       PIN_C1 ->  LED2 (OUT)                                                ** 
.................... **       PIN_C3 ->  Used as SCL for I2C communication                         ** 
.................... **       PIN_C4 ->  Used as SDA for I2C communication                         ** 
.................... **       PIN_C5 ->  Driver Enable [DE] (OUT)                                  ** 
.................... **       PIN_C6 ->  MODBBUS/RS232 Tx (OUT)                                    ** 
.................... **       PIN_C7 ->  MODBBUS/RS232 Rx (OUT)                                    ** 
.................... **       PIN_D0 ->  LED3 (OUT)                                                ** 
.................... **       PIN_D1 ->  LED4 (OUT)                                                ** 
.................... **       PIN_D2 ->  LED5 (OUT)                                                ** 
.................... **       PIN_D3 ->  LED6 (OUT)                                                ** 
.................... **       PIN_D4 ->  LED7 (OUT)                                                ** 
.................... **       PIN_D5 ->  LED8 (OUT)                                                ** 
.................... **       PIN_D6 ->  LED9 (OUT)                                                ** 
.................... **       PIN_D7 ->  LED10 (OUT)                                               ** 
.................... **                                                                            ** 
.................... **   EEPROM Location Map :                                                    ** 
.................... **       Location 0 : e_flag (for checking first run after being programmed)  ** 
.................... **       Location 1 : voltage setpoint (low byte)                             ** 
.................... **       Location 2 : voltage setpoint (high byte)                            ** 
.................... **       Location 3 : current setpoint (low byte)                             ** 
.................... **       Location 4 : current setpoint (high byte)                            ** 
.................... **       Location 5 : Parameter 3 (low byte)                                  ** 
.................... **       Location 6 : Parameter 3 (high byte)                                 ** 
.................... **       Location 7 : Parameter 4 (low byte)                                  ** 
.................... **       Location 8 : Parameter 4 (high byte)                                 ** 
.................... **       Location 9 : Parameter 5 (low byte)                                  ** 
.................... **       Location 10 : Parameter 5 (high byte)                                ** 
.................... **                                                                            ** 
.................... **   Interrupt -> Associated Function :                                       ** 
.................... **       INT_TIMER3 -> void timer_3_isr(void)                                 ** 
.................... **       INT_SSP    -> void SSP_isr(void)                                     ** 
.................... **                                                                            ** 
.................... **   Function Description :                                                   ** 
.................... **       [+] int f(int k) - Function that returns location for EEPROM         ** 
.................... **                          read/write                                        ** 
.................... **       [+] void edit_value(long lcdval) - Function for editing parameters   ** 
.................... **       [+] void lcd_print(int data) - Function for printing data on LCD     ** 
.................... **       [+] void lcd_out(int n,long val) - Function for LCD data arrangement ** 
.................... **       [+] void lcd_flash(short k,long lcd_value) - Function for flashing LCD* 
.................... **       [+] void led_on(int led) - Function for turning on specific LED      ** 
.................... **       [+] void led_off(int led) - Function for turning off specific LED    ** 
.................... **       [+] void all_leds_off() - Function for turning off all LEDs          ** 
.................... **                                                                            ** 
.................... **       [#] SSP_isr() - ISR for I2C communication                            ** 
.................... **       [#] timer_3_isr() - ISR for timer3, used for generating fixed        ** 
.................... **                           interrupts at a rate of 90ms                     ** 
.................... *******************************************************************************/ 
....................  
.................... /* INCLUDES & OTHER PREPROCESSORS --------------------------------------------*/ 
.................... #include "hardwaredefinitions.h"   // File that holds hardware definitions 
.................... #include <18f4520.h> 
.................... //////// Standard Header file for the PIC18F4520 device //////////////// 
.................... #device PIC18F4520 
.................... #list 
....................  
.................... #device ICD=TRUE ADC=10 
.................... #fuses HS,NOLVP,NOWDT,PUT,NOBROWNOUT 
.................... #use delay (clock=20000000) 
*
019A:  MOVLW  ??65535>>8
019C:  MOVWF  FSR0H
019E:  MOVLW  ??65535
01A0:  MOVWF  FSR0L
01A2:  MOVF   INDF0,W
01A4:  BZ    01C0
01A6:  MOVLW  06
01A8:  MOVWF  @01
01AA:  CLRF   @00
01AC:  DECFSZ @00,F
01AE:  BRA    01AC
01B0:  DECFSZ @01,F
01B2:  BRA    01AA
01B4:  MOVLW  7B
01B6:  MOVWF  @00
01B8:  DECFSZ @00,F
01BA:  BRA    01B8
01BC:  DECFSZ INDF0,F
01BE:  BRA    01A6
01C0:  RETURN 0
.................... #define STROBE_PIN PIN_A1 
.................... #define CLOCK_PIN PIN_A2 
.................... #define DATA_PIN PIN_A3 
.................... #define SW1 PIN_B0 
.................... #define SW2 PIN_B1 
.................... #define SW3 PIN_B2 
.................... #define SW4 PIN_B3 
.................... #define LED1 PIN_C0 
.................... #define LED2 PIN_C1 
.................... #define LED3 PIN_D0 
.................... #define LED4 PIN_D1 
.................... #define LED5 PIN_D2 
.................... #define LED6 PIN_D3 
.................... #define LED7 PIN_D4 
.................... #define LED8 PIN_D5 
.................... #define LED9 PIN_D6 
.................... #define LED10 PIN_D7 
....................  
....................  
.................... #include "functions.c"         // File that holds functions for LCD and LED 
.................... /*============================================================================*/ 
.................... /*** 
....................    * Function      : void lcd_print(int data) 
....................    * Parameters    : data  
....................    * Return value  : none 
....................    * Purpose       : Prints 8 bit data on LCD serially 
.................... ***/ 
.................... /*============================================================================*/ 
.................... void lcd_print(int data) 
.................... { 
*
0258:  MOVLW  80
025A:  MOVLB  2
025C:  MOVWF  b
....................    int b=0b10000000; 
....................     do 
....................     {      
....................        output_bit(DATA_PIN,data & b); 
025E:  MOVF   data,W
0260:  ANDWF  b,W
0262:  BNZ   0268
0264:  BCF    LATA.3
0266:  BRA    026A
0268:  BSF    LATA.3
026A:  BCF    TRISA.3
....................        output_low(CLOCK_PIN); 
026C:  BCF    TRISA.2
026E:  BCF    LATA.2
....................        output_high(CLOCK_PIN); 
0270:  BCF    TRISA.2
0272:  BSF    LATA.2
....................        rotate_right(&b , 1); 
0274:  RRNCF  b,F
....................     } while(b!=0x80); 
0276:  MOVF   b,W
0278:  SUBLW  80
027A:  BNZ   025E
....................      
....................    output_low(STROBE_PIN); 
027C:  BCF    TRISA.1
027E:  BCF    LATA.1
....................    delay_cycles(2); 
0280:  BRA    0282
....................    output_high(STROBE_PIN); 
0282:  BCF    TRISA.1
0284:  BSF    LATA.1
.................... } 
0286:  MOVLB  0
0288:  RETURN 0
....................  
.................... /*============================================================================*/ 
.................... /*** 
....................    * Function      : void lcd_out(int n, long val) 
....................    * Parameters    : n, val  
....................    * Return value  : none 
....................    * Purpose       : Manipulates and converts data to a form that could be 
....................    *                 printed on LCD.  
....................    *                 first arguement is for selection of LCD.  
....................    *                 1 for upper LCD and 2 for lower LCD 
.................... ***/ 
.................... /*============================================================================*/ 
.................... void lcd_out(int n, long val) 
.................... {              //  
028A:  MOVLB  2
028C:  CLRF   hundreds
028E:  CLRF   tens
0290:  CLRF   units
0292:  CLRF   tenths
....................    int hundreds=0, tens=0, units=0, tenths=0; 
....................    switch(n) 
....................    { 
0294:  MOVF   n,W
0296:  XORLW  01
0298:  MOVLB  0
029A:  BZ    02A4
029C:  XORLW  03
029E:  BTFSC  STATUS.Z
02A0:  BRA    0360
02A2:  BRA    041A
....................    case 1:  // for LCD 1 the segment addresses are 0x40, 0x50, 0x60 and 0x70 
....................    { 
....................       while   (val>=1000)      // separate hundreds from the number 
....................       { 
02A4:  MOVLB  2
02A6:  MOVF   val+1,W
02A8:  SUBLW  02
02AA:  BC    02C2
02AC:  XORLW  FF
02AE:  BNZ   02B6
02B0:  MOVF   val,W
02B2:  SUBLW  E7
02B4:  BC    02C2
....................       val-=1000; 
02B6:  MOVLW  E8
02B8:  SUBWF  val,F
02BA:  MOVLW  03
02BC:  SUBWFB val+1,F
....................       hundreds++; 
02BE:  INCF   hundreds,F
....................       } 
02C0:  BRA    02A6
....................     
....................       while   (val>=100)      // separate tens from the number 
....................       { 
02C2:  MOVF   val+1,F
02C4:  BNZ   02CC
02C6:  MOVF   val,W
02C8:  SUBLW  63
02CA:  BC    02D8
....................       val-=100; 
02CC:  MOVLW  64
02CE:  SUBWF  val,F
02D0:  MOVLW  00
02D2:  SUBWFB val+1,F
....................       tens++; 
02D4:  INCF   tens,F
....................       } 
02D6:  BRA    02C2
....................     
....................       while   (val>=10)       // separate units from the number                    
....................       { 
02D8:  MOVF   val+1,F
02DA:  BNZ   02E2
02DC:  MOVF   val,W
02DE:  SUBLW  09
02E0:  BC    02EE
....................       val-=10; 
02E2:  MOVLW  0A
02E4:  SUBWF  val,F
02E6:  MOVLW  00
02E8:  SUBWFB val+1,F
....................       units++; 
02EA:  INCF   units,F
....................       } 
02EC:  BRA    02D8
....................        
....................       while   (val>=1)       // separate tenths from the number                   
....................       { 
02EE:  MOVF   val+1,F
02F0:  BNZ   02F8
02F2:  MOVF   val,W
02F4:  SUBLW  00
02F6:  BC    0304
....................       val-=1; 
02F8:  MOVLW  01
02FA:  SUBWF  val,F
02FC:  MOVLW  00
02FE:  SUBWFB val+1,F
....................       tenths++; 
0300:  INCF   tenths,F
....................       } 
0302:  BRA    02EE
....................        
....................    if(hundreds==0) lcd_print(0x70 | 0x0A); 
0304:  MOVF   hundreds,F
0306:  BNZ   0314
0308:  MOVLW  7A
030A:  MOVWF  data
030C:  MOVLB  0
030E:  RCALL  0258
....................    // blank third segment if number is less than 100 
....................     
....................    else lcd_print(0x70 | hundreds); 
0310:  BRA    0320
0312:  MOVLB  2
0314:  MOVF   hundreds,W
0316:  IORLW  70
0318:  MOVWF  @@xCD
031A:  MOVWF  data
031C:  MOVLB  0
031E:  RCALL  0258
....................    // else print address of segment ORed with  respective data 
....................     
....................    if (hundreds==0 && tens==0) lcd_print(0x60 | 0x0A); 
0320:  MOVLB  2
0322:  MOVF   hundreds,F
0324:  BNZ   0336
0326:  MOVF   tens,F
0328:  BNZ   0336
032A:  MOVLW  6A
032C:  MOVWF  data
032E:  MOVLB  0
0330:  RCALL  0258
....................    // blank third and fourth segment if number is less than 10 
....................     
....................    else lcd_print(0x60 | tens); 
0332:  BRA    0342
0334:  MOVLB  2
0336:  MOVF   tens,W
0338:  IORLW  60
033A:  MOVWF  @@xCD
033C:  MOVWF  data
033E:  MOVLB  0
0340:  RCALL  0258
....................    // else print address of segment ORed with  respective data 
....................     
....................    lcd_print(0x50 | units); 
0342:  MOVLB  2
0344:  MOVF   units,W
0346:  IORLW  50
0348:  MOVWF  @@xCD
034A:  MOVWF  data
034C:  MOVLB  0
034E:  RCALL  0258
....................    // print address of segment ORed with respective data 
....................     
....................    lcd_print(0x40 | tenths); 
0350:  MOVLB  2
0352:  MOVF   tenths,W
0354:  IORLW  40
0356:  MOVWF  @@xCD
0358:  MOVWF  data
035A:  MOVLB  0
035C:  RCALL  0258
....................    // print address of segment ORed with respective data 
....................    } break; 
035E:  BRA    041C
....................     
....................    case 2: // for LCD 2 the segment addresses are 0x00, 0x10, 0x20 and 0x30 
....................    { 
....................       while   (val>=1000) 
....................       { 
0360:  MOVLB  2
0362:  MOVF   val+1,W
0364:  SUBLW  02
0366:  BC    037E
0368:  XORLW  FF
036A:  BNZ   0372
036C:  MOVF   val,W
036E:  SUBLW  E7
0370:  BC    037E
....................       val-=1000; 
0372:  MOVLW  E8
0374:  SUBWF  val,F
0376:  MOVLW  03
0378:  SUBWFB val+1,F
....................       hundreds++; 
037A:  INCF   hundreds,F
....................       } 
037C:  BRA    0362
....................     
....................       while   (val>=100) 
....................       { 
037E:  MOVF   val+1,F
0380:  BNZ   0388
0382:  MOVF   val,W
0384:  SUBLW  63
0386:  BC    0394
....................       val-=100; 
0388:  MOVLW  64
038A:  SUBWF  val,F
038C:  MOVLW  00
038E:  SUBWFB val+1,F
....................       tens++; 
0390:  INCF   tens,F
....................       } 
0392:  BRA    037E
....................     
....................       while   (val>=10) 
....................       { 
0394:  MOVF   val+1,F
0396:  BNZ   039E
0398:  MOVF   val,W
039A:  SUBLW  09
039C:  BC    03AA
....................       val-=10; 
039E:  MOVLW  0A
03A0:  SUBWF  val,F
03A2:  MOVLW  00
03A4:  SUBWFB val+1,F
....................       units++; 
03A6:  INCF   units,F
....................       } 
03A8:  BRA    0394
....................        
....................       while   (val>=1) 
....................       { 
03AA:  MOVF   val+1,F
03AC:  BNZ   03B4
03AE:  MOVF   val,W
03B0:  SUBLW  00
03B2:  BC    03C0
....................       val-=1; 
03B4:  MOVLW  01
03B6:  SUBWF  val,F
03B8:  MOVLW  00
03BA:  SUBWFB val+1,F
....................       tenths++; 
03BC:  INCF   tenths,F
....................       } 
03BE:  BRA    03AA
....................        
....................    if(hundreds==0) lcd_print(0x30 | 0x0A); 
03C0:  MOVF   hundreds,F
03C2:  BNZ   03D0
03C4:  MOVLW  3A
03C6:  MOVWF  data
03C8:  MOVLB  0
03CA:  RCALL  0258
....................    else lcd_print(0x30 | hundreds); 
03CC:  BRA    03DC
03CE:  MOVLB  2
03D0:  MOVF   hundreds,W
03D2:  IORLW  30
03D4:  MOVWF  @@xCD
03D6:  MOVWF  data
03D8:  MOVLB  0
03DA:  RCALL  0258
....................     
....................    if (hundreds==0 && tens==0) lcd_print(0x20 | 0x0A); 
03DC:  MOVLB  2
03DE:  MOVF   hundreds,F
03E0:  BNZ   03F2
03E2:  MOVF   tens,F
03E4:  BNZ   03F2
03E6:  MOVLW  2A
03E8:  MOVWF  data
03EA:  MOVLB  0
03EC:  RCALL  0258
....................    else lcd_print(0x20 | tens); 
03EE:  BRA    03FE
03F0:  MOVLB  2
03F2:  MOVF   tens,W
03F4:  IORLW  20
03F6:  MOVWF  @@xCD
03F8:  MOVWF  data
03FA:  MOVLB  0
03FC:  RCALL  0258
....................     
....................    lcd_print(0x10 | units); 
03FE:  MOVLB  2
0400:  MOVF   units,W
0402:  IORLW  10
0404:  MOVWF  @@xCD
0406:  MOVWF  data
0408:  MOVLB  0
040A:  RCALL  0258
....................    lcd_print(0x00 | tenths);  
040C:  MOVFF  tenths,@@2CD
0410:  MOVFF  tenths,data
0414:  MOVLB  0
0416:  RCALL  0258
....................   
....................    } break; 
0418:  BRA    041C
....................    default: break; 
041A:  BRA    041C
....................    }                               
.................... } 
041C:  RETURN 0
....................  
.................... /*============================================================================*/ 
.................... /*** 
....................    * Function      : void lcd_flash(short k, long lcd_value) 
....................    * Parameters    : k, lcd_value  
....................    * Return value  : none 
....................    * Purpose       : Function for flashing LCD when in edit mode. 
....................    *                 First arguement selects to blank the LCD or to show normal 
....................    *                 data. Second arguement holds data which needs to be flashed 
.................... ***/ 
.................... /*============================================================================*/ 
.................... void lcd_flash(short k, long lcd_value)  
.................... {          
....................  
....................    switch(k)       
....................    { 
041E:  MOVLB  2
0420:  MOVF   k,W
0422:  XORLW  00
0424:  MOVLB  0
0426:  BZ    042E
0428:  XORLW  01
042A:  BZ    0458
042C:  BRA    046C
....................       case 0:    // LCD2 is blanked when switch variable is 0 
....................       { 
....................          lcd_print(0x30 | 0x0A); 
042E:  MOVLW  3A
0430:  MOVLB  2
0432:  MOVWF  data
0434:  MOVLB  0
0436:  RCALL  0258
....................          lcd_print(0x20 | 0x0A); 
0438:  MOVLW  2A
043A:  MOVLB  2
043C:  MOVWF  data
043E:  MOVLB  0
0440:  RCALL  0258
....................          lcd_print(0x10 | 0x0A); 
0442:  MOVLW  1A
0444:  MOVLB  2
0446:  MOVWF  data
0448:  MOVLB  0
044A:  RCALL  0258
....................          lcd_print(0x00 | 0x0A); break;   
044C:  MOVLW  0A
044E:  MOVLB  2
0450:  MOVWF  data
0452:  MOVLB  0
0454:  RCALL  0258
0456:  BRA    046C
....................       } 
....................        
....................       case 1:   // normal data is printed on LCD2 when switch variable is 1  
....................       { 
....................          lcd_out(2, lcd_value); break; 
0458:  MOVLW  02
045A:  MOVLB  2
045C:  MOVWF  n
045E:  MOVFF  lcd_value+1,val+1
0462:  MOVFF  lcd_value,val
0466:  MOVLB  0
0468:  RCALL  028A
046A:  BRA    046C
....................       } 
....................    } 
.................... } 
046C:  GOTO   052A (RETURN)
....................  
.................... /*============================================================================*/ 
.................... /*** 
....................    * Function      : void led_on(int led) 
....................    * Parameters    : led  
....................    * Return value  : none 
....................    * Purpose       : Function for switching on respective LED. 
.................... ***/ 
.................... /*============================================================================*/ 
.................... void led_on(int led) 
.................... { 
....................    switch(led) 
....................    { 
*
01C2:  MOVLW  01
01C4:  MOVLB  2
01C6:  SUBWF  led,W
01C8:  ADDLW  F6
01CA:  BC    0226
01CC:  ADDLW  0A
01CE:  MOVLB  0
01D0:  GOTO   @goto10150
....................    case 1: output_high(PIN_C0); break; 
01D4:  BCF    TRISC.0
01D6:  BSF    LATC.0
01D8:  MOVLB  2
01DA:  BRA    0226
....................    case 2: output_high(PIN_C1); break; 
01DC:  BCF    TRISC.1
01DE:  BSF    LATC.1
01E0:  MOVLB  2
01E2:  BRA    0226
....................    case 3: output_high(PIN_D0); break; 
01E4:  BCF    TRISD.0
01E6:  BSF    LATD.0
01E8:  MOVLB  2
01EA:  BRA    0226
....................    case 4: output_high(PIN_D1); break; 
01EC:  BCF    TRISD.1
01EE:  BSF    LATD.1
01F0:  MOVLB  2
01F2:  BRA    0226
....................    case 5: output_high(PIN_D2); break; 
01F4:  BCF    TRISD.2
01F6:  BSF    LATD.2
01F8:  MOVLB  2
01FA:  BRA    0226
....................    case 6: output_high(PIN_D3); break; 
01FC:  BCF    TRISD.3
01FE:  BSF    LATD.3
0200:  MOVLB  2
0202:  BRA    0226
....................    case 7: output_high(PIN_D4); break; 
0204:  BCF    TRISD.4
0206:  BSF    LATD.4
0208:  MOVLB  2
020A:  BRA    0226
....................    case 8: output_high(PIN_D5); break; 
020C:  BCF    TRISD.5
020E:  BSF    LATD.5
0210:  MOVLB  2
0212:  BRA    0226
....................    case 9: output_high(PIN_D6); break; 
0214:  BCF    TRISD.6
0216:  BSF    LATD.6
0218:  MOVLB  2
021A:  BRA    0226
....................    case 10: output_high(PIN_D7); break; 
021C:  BCF    TRISD.7
021E:  BSF    LATD.7
0220:  MOVLB  2
0222:  BRA    0226
0224:  MOVLB  2
....................    } 
.................... } 
0226:  MOVLB  0
0228:  RETURN 0
....................  
.................... /*============================================================================*/ 
.................... /*** 
....................    * Function      : void led_off(int led) 
....................    * Parameters    : led  
....................    * Return value  : none 
....................    * Purpose       : Function for switching off respective LED. 
.................... ***/ 
.................... /*============================================================================*/ 
.................... void led_off(int led)       
.................... { 
....................    switch(led) 
....................    { 
*
0470:  MOVLW  01
0472:  MOVLB  2
0474:  SUBWF  led,W
0476:  ADDLW  F6
0478:  BC    04D4
047A:  ADDLW  0A
047C:  MOVLB  0
047E:  GOTO   @goto10169
....................    case 1: output_low(PIN_C0); break; 
0482:  BCF    TRISC.0
0484:  BCF    LATC.0
0486:  MOVLB  2
0488:  BRA    04D4
....................    case 2: output_low(PIN_C1); break; 
048A:  BCF    TRISC.1
048C:  BCF    LATC.1
048E:  MOVLB  2
0490:  BRA    04D4
....................    case 3: output_low(PIN_D0); break; 
0492:  BCF    TRISD.0
0494:  BCF    LATD.0
0496:  MOVLB  2
0498:  BRA    04D4
....................    case 4: output_low(PIN_D1); break; 
049A:  BCF    TRISD.1
049C:  BCF    LATD.1
049E:  MOVLB  2
04A0:  BRA    04D4
....................    case 5: output_low(PIN_D2); break; 
04A2:  BCF    TRISD.2
04A4:  BCF    LATD.2
04A6:  MOVLB  2
04A8:  BRA    04D4
....................    case 6: output_low(PIN_D3); break; 
04AA:  BCF    TRISD.3
04AC:  BCF    LATD.3
04AE:  MOVLB  2
04B0:  BRA    04D4
....................    case 7: output_low(PIN_D4); break; 
04B2:  BCF    TRISD.4
04B4:  BCF    LATD.4
04B6:  MOVLB  2
04B8:  BRA    04D4
....................    case 8: output_low(PIN_D5); break; 
04BA:  BCF    TRISD.5
04BC:  BCF    LATD.5
04BE:  MOVLB  2
04C0:  BRA    04D4
....................    case 9: output_low(PIN_D6); break; 
04C2:  BCF    TRISD.6
04C4:  BCF    LATD.6
04C6:  MOVLB  2
04C8:  BRA    04D4
....................    case 10: output_low(PIN_D7); break; 
04CA:  BCF    TRISD.7
04CC:  BCF    LATD.7
04CE:  MOVLB  2
04D0:  BRA    04D4
04D2:  MOVLB  2
....................    } 
.................... } 
04D4:  MOVLB  0
04D6:  RETURN 0
....................  
.................... /*============================================================================*/ 
.................... /*** 
....................    * Function      : void all_leds_off() 
....................    * Parameters    : none  
....................    * Return value  : none 
....................    * Purpose       : Function for switching off all LEDs. 
.................... ***/ 
.................... /*============================================================================*/ 
.................... void all_leds_off()       
.................... { 
....................    output_low(LED1); 
*
017C:  BCF    TRISC.0
017E:  BCF    LATC.0
....................    output_low(LED2); 
0180:  BCF    TRISC.1
0182:  BCF    LATC.1
....................    output_d(0); 
0184:  CLRF   TRISD
0186:  CLRF   LATD
.................... } 
0188:  GOTO   07A4 (RETURN)
....................  
.................... /****************************** END OF FILE  **********************************/ 
....................  
....................  
....................  
.................... #USE I2C(SLAVE,SDA=PIN_C4, SCL=PIN_C3,ADDRESS=0xA0) 
*
00BA:  MOVF   SSPBUF,W
00BC:  MOVFF  ??65535,SSPBUF
00C0:  BSF    SSPCON1.CKP
00C2:  BCF    PIR1.SSPIF
00C4:  BTFSC  SSPSTAT.BF
00C6:  BRA    00C4
00C8:  CLRF   @01
00CA:  BTFSC  SSPCON1.CKP
00CC:  INCF   @01,F
00CE:  GOTO   0148 (RETURN)
....................  
.................... /* DEFINES -------------------------------------------------------------------*/ 
.................... /* Maximum voltage to which editing of voltage set point is limited */ 
.................... #define max_voltage   30 
....................  
.................... /* Minimum voltage to which editing of voltage set point is limited */ 
.................... #define min_voltage   0 
....................  
.................... /* maximum value of current to which editing of voltage set point is limited */ 
.................... #define max_current_in_mA   960  
....................  
.................... /* Minimum value of current to which editing of voltage set point is limited */ 
.................... #define min_current_in_mA   0 
....................  
.................... /* Initial voltage setpoint that is effective when program executed first time*/ 
.................... #define initial_setpoint_for_voltage 13.2 
....................  
.................... /* Initial current limit that is effective when program executed first time */ 
.................... #define initial_current_limit_in_mA 500 
....................  
.................... /* GLOBAL VARIABLES ----------------------------------------------------------*/ 
.................... int1 show_parameters_mode=0, edit_parameters_mode=FALSE, flash=FALSE; 
.................... int state=0 , e_flag=0, address, a, low_byte, high_byte, delay_time=125; 
.................... int edit_counter=0, flash_counter=0, menu_timeout_monitor=0; 
.................... int data[500], reading[128]; 
.................... long loop_execution_counter=0; 
.................... long value[5]; 
.................... long max_setpoint_vo=max_voltage*10; 
.................... long min_setpoint_vo=min_voltage*10; 
.................... long max_current_limit=max_current_in_mA*10; 
.................... long min_current_limit=min_current_in_mA*10; 
....................  
.................... /*============================================================================*/ 
.................... /*** 
....................    * Function      : void SSP_isr(void) 
....................    * Parameters    : None   
....................    * Return value  : None 
....................    * Purpose       : Sends/Receives Data to/from master CPU 
.................... ***/ 
.................... /*============================================================================*/ 
.................... #INT_SSP 
.................... void SSP_isr(void)  
.................... { 
....................    state = i2c_isr_state(); 
00D2:  BTFSC  SSPSTAT.D
00D4:  BRA    00DE
00D6:  MOVLB  2
00D8:  CLRF   @I2C_STATE
00DA:  BTFSC  SSPSTAT.R
00DC:  BSF    @I2C_STATE.7
00DE:  MOVLB  2
00E0:  MOVF   @I2C_STATE,W
00E2:  INCF   @I2C_STATE,F
00E4:  MOVWF  state
....................       if (state < 128) 
00E6:  MOVF   state,W
00E8:  SUBLW  7F
00EA:  BNC   0128
....................       { 
....................          /* If device address matched, then receive data from master */ 
....................          if(state==0) address=i2c_read(); 
00EC:  MOVF   state,F
00EE:  BNZ   00FE
00F0:  BCF    SSPCON1.SSPOV
00F2:  BTFSS  PIR1.SSPIF
00F4:  BRA    00F2
00F6:  MOVF   SSPBUF,W
00F8:  BSF    SSPCON1.CKP
00FA:  MOVWF  address
....................  
....................          else if (state >= 1 && state < 128)     
00FC:  BRA    0126
00FE:  MOVF   state,W
0100:  SUBLW  00
0102:  BC    0126
0104:  MOVF   state,W
0106:  SUBLW  7F
0108:  BNC   0126
....................          reading[state-1] = i2c_read();  // Store Data in array one by one 
010A:  MOVLW  01
010C:  SUBWF  state,W
010E:  CLRF   @03
0110:  ADDLW  reading
0112:  MOVWF  FSR0L
0114:  MOVLW  reading>>8
0116:  ADDWFC @03,W
0118:  MOVWF  FSR0H
011A:  BCF    SSPCON1.SSPOV
011C:  BTFSS  PIR1.SSPIF
011E:  BRA    011C
0120:  MOVF   SSPBUF,W
0122:  BSF    SSPCON1.CKP
0124:  MOVWF  INDF0
....................       }   
....................        
....................       else if (state >= 128)  // If Master is requesting Data 
0126:  BRA    014A
0128:  MOVF   state,W
012A:  SUBLW  7F
012C:  BC    014A
....................       i2c_write (data[state - 127]);       // Send Data to Master 
012E:  MOVLW  7F
0130:  SUBWF  state,W
0132:  ADDLW  data
0134:  MOVWF  FSR0L
0136:  CLRF   FSR0H
0138:  BTFSC  STATUS.C
013A:  INCF   FSR0H,F
013C:  MOVFF  INDF0,@@2D0
0140:  MOVFF  @@2D0,??65535
0144:  MOVLB  0
0146:  BRA    00BA
0148:  MOVLB  2
.................... } 
....................  
.................... /*============================================================================*/ 
.................... /*** 
....................    * Function      : void timer_3_isr(void) 
....................    * Parameters    : None   
....................    * Return value  : None 
....................    * Purpose       : Used for timeouts and flashing purposes 
.................... ***/ 
.................... /*============================================================================*/ 
014A:  BCF    PIR1.SSPIF
014C:  MOVLB  0
014E:  GOTO   006C
.................... #INT_TIMER3 
.................... void timer_3_isr(void) 
.................... {    
....................    if (show_parameters_mode==TRUE && edit_parameters_mode==TRUE) edit_counter++; 
0152:  BTFSS  19.0
0154:  BRA    015E
0156:  BTFSS  19.1
0158:  BRA    015E
015A:  INCF   edit_counter,F
....................    // edit_counter increments every 90 ms when in edit mode 
....................     
....................    else if (show_parameters_mode==TRUE) menu_timeout_monitor++; 
015C:  BRA    0162
015E:  BTFSC  19.0
0160:  INCF   menu_timeout_monitor,F
....................    // menu timeout counter increments every 90 ms when in menu stage 0 
....................     
....................    flash_counter++;     // flash_counter increments every 90 ms 
0162:  INCF   flash_counter,F
....................     
....................    if (flash_counter==3) // if 90ms*3= 270 ms have passed, then complement flag 
0164:  MOVF   flash_counter,W
0166:  SUBLW  03
0168:  BNZ   016E
....................    { flash=~flash; flash_counter=0;}   
016A:  BTG    flash
016C:  CLRF   flash_counter
....................     
....................    set_timer3(9286);      // set timer 3 to generate interrupt every 90 ms 
016E:  MOVLW  24
0170:  MOVWF  TMR3H
0172:  MOVLW  46
0174:  MOVWF  TMR3L
.................... } 
....................  
.................... /*============================================================================*/ 
.................... /*** 
....................    * Function      : int f(int k) 
....................    * Parameters    : int k   
....................    * Return value  : int 
....................    * Purpose       : Returns location for EEPROM read and write 
.................... ***/ 
.................... /*============================================================================*/ 
0176:  BCF    PIR2.TMR3IF
0178:  GOTO   006C
.................... int f(int k) 
.................... { 
....................    return (k*2)+1; 
*
018C:  BCF    STATUS.C
018E:  MOVLB  2
0190:  RLCF   k,W
0192:  ADDLW  01
0194:  MOVWF  @01
.................... } 
0196:  MOVLB  0
0198:  RETURN 0
....................  
.................... /*============================================================================*/ 
.................... /*** 
....................    * Function      : void edit_value(long lcdval) 
....................    * Parameters    : long lcdval  
....................    * Return value  : none 
....................    * Purpose       : Edits parameter values 
.................... ***/ 
.................... /*============================================================================*/ 
.................... void edit_value(long lcdval) 
.................... {   
....................    led_on(3);       // LED 3 is on for indication of menu stage 1 (or edit mode) 
*
0506:  MOVLW  03
0508:  MOVLB  2
050A:  MOVWF  led
050C:  MOVLB  0
050E:  RCALL  01C2
....................    edit_parameters_mode=TRUE;   // Flag to indicate edit mode 
0510:  BSF    edit_parameters_mode
....................  
....................    do 
....................    {   
....................       /* call function for flashing LCD with lcdval every 270 ms */ 
....................       lcd_flash(flash,lcdval); 
0512:  MOVLW  00
0514:  BTFSC  flash
0516:  MOVLW  01
0518:  MOVLB  2
051A:  MOVWF  @@xC2
051C:  MOVWF  k
051E:  MOVFF  lcdval+1,lcd_value+1
0522:  MOVFF  lcdval,lcd_value
0526:  MOVLB  0
0528:  BRA    041E
....................        
....................       while(!input(SW2)) 
....................          { 
052A:  BSF    TRISB.1
052C:  BTFSC  PORTB.1
052E:  BRA    0616
....................             delay_ms(delay_time);  /* delay for debouncing. Also used for fast 
0530:  MOVFF  delay_time,??65535
0534:  RCALL  019A
....................                                     *  increment/decrement */ 
....................             edit_counter=0; /* reset edit counter on button press so that  
0536:  CLRF   edit_counter
....................                              * timeout does not occur */ 
....................             loop_execution_counter++;   // increment on every execution 
0538:  MOVLB  2
053A:  INCF   x98,F
053C:  BTFSC  STATUS.Z
053E:  INCF   loop_execution_counter+1,F
....................              
....................             /* a is the pointer for parameter value.  
....................              * if a is 0 then parameter 1 is selected */ 
....................             if (a==0) 
0540:  MOVF   a,F
0542:  BNZ   055E
....................             { 
....................                /* Parameter 1 is setpoint voltage.  
....................                 * No increment if max value reached */ 
....................                if(lcdval==max_setpoint_vo) break; 
0544:  MOVF   max_setpoint_vo,W
0546:  SUBWF  lcdval,W
0548:  BNZ   0556
054A:  MOVF   max_setpoint_vo+1,W
054C:  SUBWF  lcdval+1,W
054E:  BNZ   0556
0550:  MOVLB  0
0552:  BRA    0616
0554:  MOVLB  2
....................                 
....................                lcdval++;   /* Increment one value if within limits. 
0556:  INCF   xC0,F
0558:  BTFSC  STATUS.Z
055A:  INCF   lcdval+1,F
....................                             * decimal point in LCD shows 0.1 Volt increment */ 
....................             } 
....................              
....................             else if (a==1)   // if a is 1 then parameter 2 is selected 
055C:  BRA    058A
055E:  DECFSZ a,W
0560:  BRA    058A
....................             { 
....................                /* parameter 2 is max current limit.  
....................                 * No increment if maximum value reached */ 
....................                if(lcdval==max_current_limit) break; 
0562:  MOVF   max_current_limit,W
0564:  SUBWF  lcdval,W
0566:  BNZ   0574
0568:  MOVF   max_current_limit+1,W
056A:  SUBWF  lcdval+1,W
056C:  BNZ   0574
056E:  MOVLB  0
0570:  BRA    0616
0572:  MOVLB  2
....................  
....................                if(loop_execution_counter>=32) delay_time=10;  
0574:  MOVF   loop_execution_counter+1,F
0576:  BNZ   057E
0578:  MOVF   loop_execution_counter,W
057A:  SUBLW  1F
057C:  BC    0582
057E:  MOVLW  0A
0580:  MOVWF  delay_time
....................                /* change debouncing delay from 125 to 10 if button has been 
....................                 * pressed for 4 sec.  
....................                 * 125 ms * 32 = 4 sec  */ 
....................   
....................                lcdval+=10; /* Increment 10 values if within limits.  
0582:  MOVLW  0A
0584:  ADDWF  lcdval,F
0586:  MOVLW  00
0588:  ADDWFC lcdval+1,F
....................                             * decimal point in LCD will show 1 mA increment */ 
....................             } 
....................             lcd_out(2,lcdval);   // display the final value on LCD2 
058A:  MOVLW  02
058C:  MOVWF  n
058E:  MOVFF  lcdval+1,val+1
0592:  MOVFF  lcdval,val
0596:  MOVLB  0
0598:  RCALL  028A
....................              
....................             /* value array used for storing 5 parameters against respective  
....................              * pointer a */ 
....................             value[a]=lcdval; 
059A:  BCF    STATUS.C
059C:  RLCF   a,W
059E:  CLRF   @03
05A0:  ADDLW  value
05A2:  MOVWF  FSR0L
05A4:  MOVLW  value>>8
05A6:  ADDWFC @03,W
05A8:  MOVWF  FSR0H
05AA:  MOVFF  lcdval+1,PREINC0
05AE:  MOVF   POSTDEC0,F
05B0:  MOVFF  lcdval,INDF0
....................             low_byte=value[a];    // separate low byte of int16 data 
05B4:  BCF    STATUS.C
05B6:  RLCF   a,W
05B8:  CLRF   @03
05BA:  ADDLW  value
05BC:  MOVWF  FSR0L
05BE:  MOVLW  value>>8
05C0:  ADDWFC @03,W
05C2:  MOVWF  FSR0H
05C4:  MOVFF  INDF0,low_byte
....................             high_byte=value[a]>>8;   // shift right and separate high byte 
05C8:  BCF    STATUS.C
05CA:  RLCF   a,W
05CC:  CLRF   @03
05CE:  ADDLW  value
05D0:  MOVWF  FSR0L
05D2:  MOVLW  value>>8
05D4:  ADDWFC @03,W
05D6:  MOVWF  FSR0H
05D8:  MOVFF  PREINC0,@@2C3
05DC:  MOVF   POSTDEC0,F
05DE:  MOVFF  INDF0,@@2C2
05E2:  MOVFF  @@2C3,high_byte
....................                
....................             // store low byte in data array on location 1 when pointer a=0 
....................             data[f(a)]=low_byte; 
05E6:  MOVFF  a,k
05EA:  RCALL  018C
05EC:  MOVLW  data
05EE:  ADDWF  @01,W
05F0:  MOVWF  FSR0L
05F2:  CLRF   FSR0H
05F4:  BTFSC  STATUS.C
05F6:  INCF   FSR0H,F
05F8:  MOVFF  low_byte,INDF0
....................                
....................             // store high byte in data array on location 2 when pointer a=0 
....................             data[f(a)+1]=high_byte; 
05FC:  MOVFF  a,k
0600:  RCALL  018C
0602:  MOVLW  01
0604:  ADDWF  @01,W
0606:  ADDLW  data
0608:  MOVWF  FSR0L
060A:  CLRF   FSR0H
060C:  BTFSC  STATUS.C
060E:  INCF   FSR0H,F
0610:  MOVFF  high_byte,INDF0
....................                
....................               /* Data array will be accessed by Master PC through ISR. The 
....................                * master controller reads edited parameter values after every 
....................                * second. The data array needs to be updated every time there is 
....................                * a change in parameter */ 
....................          } 
0614:  BRA    052A
....................          while(!input(SW3)) // this loop is for decrement. 
....................          { 
0616:  BSF    TRISB.2
0618:  BTFSC  PORTB.2
061A:  BRA    0704
....................             delay_ms(delay_time); 
061C:  MOVFF  delay_time,??65535
0620:  RCALL  019A
....................             edit_counter=0;          
0622:  CLRF   edit_counter
....................             loop_execution_counter++; 
0624:  MOVLB  2
0626:  INCF   x98,F
0628:  BTFSC  STATUS.Z
062A:  INCF   loop_execution_counter+1,F
....................             if (a==0) 
062C:  MOVF   a,F
062E:  BNZ   064C
....................             { 
....................                if(lcdval==min_setpoint_vo) break; 
0630:  MOVF   min_setpoint_vo,W
0632:  SUBWF  lcdval,W
0634:  BNZ   0642
0636:  MOVF   min_setpoint_vo+1,W
0638:  SUBWF  lcdval+1,W
063A:  BNZ   0642
063C:  MOVLB  0
063E:  BRA    0704
0640:  MOVLB  2
....................                lcdval--; 
0642:  MOVF   lcdval,W
0644:  BTFSC  STATUS.Z
0646:  DECF   lcdval+1,F
0648:  DECF   lcdval,F
....................             } 
....................             else if (a==1) 
064A:  BRA    0678
064C:  DECFSZ a,W
064E:  BRA    0678
....................             { 
....................                if(lcdval==min_current_limit) break; 
0650:  MOVF   min_current_limit,W
0652:  SUBWF  lcdval,W
0654:  BNZ   0662
0656:  MOVF   min_current_limit+1,W
0658:  SUBWF  lcdval+1,W
065A:  BNZ   0662
065C:  MOVLB  0
065E:  BRA    0704
0660:  MOVLB  2
....................                if(loop_execution_counter>=32) delay_time=10; 
0662:  MOVF   loop_execution_counter+1,F
0664:  BNZ   066C
0666:  MOVF   loop_execution_counter,W
0668:  SUBLW  1F
066A:  BC    0670
066C:  MOVLW  0A
066E:  MOVWF  delay_time
....................                lcdval-=10; 
0670:  MOVLW  0A
0672:  SUBWF  lcdval,F
0674:  MOVLW  00
0676:  SUBWFB lcdval+1,F
....................             } 
....................             lcd_out(2,lcdval); 
0678:  MOVLW  02
067A:  MOVWF  n
067C:  MOVFF  lcdval+1,val+1
0680:  MOVFF  lcdval,val
0684:  MOVLB  0
0686:  RCALL  028A
....................             value[a]=lcdval; 
0688:  BCF    STATUS.C
068A:  RLCF   a,W
068C:  CLRF   @03
068E:  ADDLW  value
0690:  MOVWF  FSR0L
0692:  MOVLW  value>>8
0694:  ADDWFC @03,W
0696:  MOVWF  FSR0H
0698:  MOVFF  lcdval+1,PREINC0
069C:  MOVF   POSTDEC0,F
069E:  MOVFF  lcdval,INDF0
....................             low_byte=value[a]; 
06A2:  BCF    STATUS.C
06A4:  RLCF   a,W
06A6:  CLRF   @03
06A8:  ADDLW  value
06AA:  MOVWF  FSR0L
06AC:  MOVLW  value>>8
06AE:  ADDWFC @03,W
06B0:  MOVWF  FSR0H
06B2:  MOVFF  INDF0,low_byte
....................             high_byte=value[a]>>8; 
06B6:  BCF    STATUS.C
06B8:  RLCF   a,W
06BA:  CLRF   @03
06BC:  ADDLW  value
06BE:  MOVWF  FSR0L
06C0:  MOVLW  value>>8
06C2:  ADDWFC @03,W
06C4:  MOVWF  FSR0H
06C6:  MOVFF  PREINC0,@@2C3
06CA:  MOVF   POSTDEC0,F
06CC:  MOVFF  INDF0,@@2C2
06D0:  MOVFF  @@2C3,high_byte
....................             data[f(a)]=low_byte; 
06D4:  MOVFF  a,k
06D8:  RCALL  018C
06DA:  MOVLW  data
06DC:  ADDWF  @01,W
06DE:  MOVWF  FSR0L
06E0:  CLRF   FSR0H
06E2:  BTFSC  STATUS.C
06E4:  INCF   FSR0H,F
06E6:  MOVFF  low_byte,INDF0
....................             data[f(a)+1]=high_byte; 
06EA:  MOVFF  a,k
06EE:  RCALL  018C
06F0:  MOVLW  01
06F2:  ADDWF  @01,W
06F4:  ADDLW  data
06F6:  MOVWF  FSR0L
06F8:  CLRF   FSR0H
06FA:  BTFSC  STATUS.C
06FC:  INCF   FSR0H,F
06FE:  MOVFF  high_byte,INDF0
....................          } 
0702:  BRA    0616
....................       loop_execution_counter=0; 
0704:  MOVLB  2
0706:  CLRF   loop_execution_counter+1
0708:  CLRF   loop_execution_counter
....................       delay_time=125; 
070A:  MOVLW  7D
070C:  MOVWF  delay_time
....................     
....................    // if no editing is done for 56 * 90 ms = 5.04 second, then break 
....................    if (edit_counter==56) break; 
070E:  MOVF   edit_counter,W
0710:  SUBLW  38
0712:  BNZ   0716
0714:  BRA    0720
....................    }while(input(SW1));      // exit from loop when switch 1 is pressed 
0716:  BSF    TRISB.0
0718:  BTFSS  PORTB.0
071A:  BRA    0720
071C:  MOVLB  0
071E:  BRA    0512
....................     
....................    delay_ms(50);            // Delay for debouncing 
0720:  MOVLW  32
0722:  MOVWF  ??65535
0724:  MOVLB  0
0726:  RCALL  019A
....................    while(!input(SW1));      // halt here if bounce still exists 
0728:  BSF    TRISB.0
072A:  BTFSS  PORTB.0
072C:  BRA    0728
....................     
....................    edit_counter=0;           // reset edit counter 
072E:  CLRF   edit_counter
....................     
....................    /* clear flag to indicate an exit from "edit parameters mode" */ 
....................    edit_parameters_mode=FALSE; 
0730:  BCF    edit_parameters_mode
....................    led_off(3);               // turn off indication LED3 
0732:  MOVLW  03
0734:  MOVLB  2
0736:  MOVWF  led
0738:  MOVLB  0
073A:  RCALL  0470
.................... } 
073C:  GOTO   0B9C (RETURN)
....................  
.................... /*============================================================================*/ 
.................... /*** 
....................    * Function     : void main(void) 
....................    * Parameters   : None   
....................    * Return value : None 
....................    * Purpose      : Serves for the following purposes: 
....................    *                [+] Displays voltage and current values on LCDs 
....................    *                [+] Scans menu button SW4 and calls edit function if pressed 
....................    *                [+] Reads/writes values to EEPROM 
....................    *                [+] Loops forever 
.................... ***/ 
.................... /*============================================================================*/ 
.................... void main(void) 
.................... {  
0740:  CLRF   TBLPTRU
0742:  BCF    RCON.IPEN
0744:  BSF    07.7
0746:  CLRF   FSR0H
0748:  CLRF   FSR0L
074A:  BSF    TRISC.3
074C:  BSF    TRISC.4
074E:  MOVLW  A0
0750:  MOVWF  SSPADD
0752:  MOVLW  36
0754:  MOVWF  SSPCON1
0756:  BCF    show_parameters_mode
0758:  BCF    edit_parameters_mode
075A:  BCF    flash
075C:  CLRF   state
075E:  CLRF   e_flag
0760:  MOVLW  7D
0762:  MOVWF  delay_time
0764:  CLRF   edit_counter
0766:  CLRF   flash_counter
0768:  CLRF   menu_timeout_monitor
076A:  MOVLB  2
076C:  CLRF   loop_execution_counter+1
076E:  CLRF   loop_execution_counter
0770:  MOVLW  01
0772:  MOVWF  max_setpoint_vo+1
0774:  MOVLW  2C
0776:  MOVWF  max_setpoint_vo
0778:  CLRF   min_setpoint_vo+1
077A:  CLRF   min_setpoint_vo
077C:  MOVLW  25
077E:  MOVWF  max_current_limit+1
0780:  MOVLW  80
0782:  MOVWF  max_current_limit
0784:  CLRF   min_current_limit+1
0786:  CLRF   min_current_limit
0788:  MOVLW  03
078A:  MOVWF  @I2C_STATE
078C:  MOVF   ADCON1,W
078E:  ANDLW  C0
0790:  IORLW  0F
0792:  MOVWF  ADCON1
0794:  MOVLW  07
0796:  MOVWF  CMCON
....................    output_high(STROBE_PIN);   // De-activate the strobe pin 
0798:  BCF    TRISA.1
079A:  BSF    LATA.1
....................    output_high(CLOCK_PIN);      // De-activate the clock pin 
079C:  BCF    TRISA.2
079E:  BSF    LATA.2
....................    all_leds_off();            // Make all LEDs off initially 
07A0:  MOVLB  0
07A2:  BRA    017C
....................     
....................    enable_interrupts(INT_SSP);   // Enable Interrupt for SPI or I2C activity 
07A4:  BSF    PIE1.SSPIE
....................    setup_timer_3 (T3_INTERNAL | T3_DIV_BY_8); //16-Bit Timer;1.6 usec for 1 tick 
07A6:  MOVLW  B5
07A8:  MOVWF  T3CON
....................    enable_interrupts(GLOBAL);      // Enable global interrupts 
07AA:  MOVLW  C0
07AC:  IORWF  INTCON,F
....................     
....................    // long variable to hold values to be shown on LCD 1 and LCD 2 
....................    long lcd_1_val, lcd_2_val;  
....................     
....................    /* long variables that hold values of voltage and current received from 
....................     * master controller */ 
....................    long voltage, current; 
....................    long temp_val;     // temporary LCD value that is going to be edited by user 
....................     
....................    /* variables that hold high and low values of parameters */ 
....................    long high_val, low_val; 
....................     
....................    // menu array with five menu numbers from 1 till 5, decimal point is in LCD 
....................    int menu[5]={10,20,30,40,50};    
07AE:  MOVLW  0A
07B0:  MOVLB  2
07B2:  MOVWF  menu
07B4:  MOVLW  14
07B6:  MOVWF  menu+1
07B8:  MOVLW  1E
07BA:  MOVWF  menu+2
07BC:  MOVLW  28
07BE:  MOVWF  menu+3
07C0:  MOVLW  32
07C2:  MOVWF  menu+4
....................    reading[0]=0xB8; 
07C4:  MOVLW  B8
07C6:  MOVWF  reading
....................    reading[2]=0xB8; 
07C8:  MOVWF  reading+2
....................    reading[1]=0x22; 
07CA:  MOVLW  22
07CC:  MOVWF  reading+1
....................    reading[3]=0x22; 
07CE:  MOVWF  reading+3
....................    /* These four lines are for displaying 8888 on both LCDs when no data has 
....................     * been received from Master controller */ 
....................     
....................     
....................    e_flag=read_eeprom(0); 
07D0:  MOVFF  INTCON,@@2C0
07D4:  BCF    INTCON.GIE_GIEH
07D6:  CLRF   EEADR
07D8:  BCF    EECON1.CFGS
07DA:  BCF    EECON1.EEPGD
07DC:  BSF    EECON1.RD
07DE:  MOVF   EEDATA,W
07E0:  BTFSC  @@xC0.7
07E2:  BSF    INTCON.GIE_GIEH
07E4:  MOVWF  e_flag
....................    /* Flag to hold value of first location of EEPROM after being programmed 
....................     * the internal EEPROM hold 0xFF value in all locations initially */ 
....................  
....................    /* Write arbitrary values into EEPROM if Started for the first time 
....................     * if e_flag holds a non-zero value then execute the following commands */ 
....................    if (e_flag) 
07E6:  MOVF   e_flag,F
07E8:  BTFSC  STATUS.Z
07EA:  BRA    08EE
....................    { 
....................       e_flag=0;   // make the e_flag=0 
07EC:  CLRF   e_flag
....................       write_eeprom(0,e_flag); // store 0 in location 0 of EEPROM 
07EE:  CLRF   EEADR
07F0:  MOVFF  e_flag,EEDATA
07F4:  BCF    EECON1.CFGS
07F6:  BCF    EECON1.EEPGD
07F8:  BSF    EECON1.WREN
07FA:  MOVF   INTCON,W
07FC:  MOVWF  @00
07FE:  BCF    INTCON.GIE_GIEH
0800:  MOVLB  F
0802:  MOVLW  55
0804:  MOVWF  EECON2
0806:  MOVLW  AA
0808:  MOVWF  EECON2
080A:  BSF    EECON1.WR
080C:  BTFSC  EECON1.WR
080E:  BRA    080C
0810:  BCF    EECON1.WREN
0812:  MOVF   @00,W
0814:  IORWF  INTCON,F
....................        
....................       // voltage set_point multiplied by 10 and stored as parameter 1 
....................       value[0]=initial_setpoint_for_voltage*10; 
0816:  MOVLB  2
0818:  CLRF   value+1
081A:  MOVLW  84
081C:  MOVWF  value
....................        
....................       // max current limit multiplied by 10 and stored as parameter 2 
....................       value[1]=initial_current_limit_in_mA*10;    
081E:  MOVLW  13
0820:  MOVWF  value+3
0822:  MOVLW  88
0824:  MOVWF  value+2
....................        
....................       value[2]=2500;      // arbitrary value for parameter 3 
0826:  MOVLW  09
0828:  MOVWF  value+5
082A:  MOVLW  C4
082C:  MOVWF  value+4
....................       value[3]=3500;      // arbitrary value for parameter 4 
082E:  MOVLW  0D
0830:  MOVWF  value+7
0832:  MOVLW  AC
0834:  MOVWF  value+6
....................       value[4]=6500;      // arbitrary value for parameter 5 
0836:  MOVLW  19
0838:  MOVWF  value+9
083A:  MOVLW  64
083C:  MOVWF  value+8
....................  
....................       // copy the initial values into EEPROM on respective locations 
....................       for (a=0 ; a<=4 ; a++) 
083E:  CLRF   a
0840:  MOVF   a,W
0842:  SUBLW  04
0844:  BNC   08EE
....................       {  
....................          // copy low byte of value array for respective pointer  
....................          low_byte=value[a]; 
0846:  BCF    STATUS.C
0848:  RLCF   a,W
084A:  CLRF   @03
084C:  ADDLW  value
084E:  MOVWF  FSR0L
0850:  MOVLW  value>>8
0852:  ADDWFC @03,W
0854:  MOVWF  FSR0H
0856:  MOVFF  INDF0,low_byte
....................           
....................          // copy high byte of value array for respective pointer 
....................          high_byte=value[a]>>8; 
085A:  BCF    STATUS.C
085C:  RLCF   a,W
085E:  CLRF   @03
0860:  ADDLW  value
0862:  MOVWF  FSR0L
0864:  MOVLW  value>>8
0866:  ADDWFC @03,W
0868:  MOVWF  FSR0H
086A:  MOVFF  PREINC0,@@2C1
086E:  MOVF   POSTDEC0,F
0870:  MOVFF  INDF0,@@2C0
0874:  MOVFF  @@2C1,high_byte
....................           
....................          //store low byte in EEPROM on location determined by f(a) 
....................          write_eeprom(f(a),low_byte); 
0878:  MOVFF  a,k
087C:  MOVLB  0
087E:  RCALL  018C
0880:  MOVFF  01,@@2C0
0884:  MOVFF  @@2C0,EEADR
0888:  MOVFF  low_byte,EEDATA
088C:  BCF    EECON1.CFGS
088E:  BCF    EECON1.EEPGD
0890:  BSF    EECON1.WREN
0892:  MOVF   INTCON,W
0894:  MOVWF  @00
0896:  BCF    INTCON.GIE_GIEH
0898:  MOVLB  F
089A:  MOVLW  55
089C:  MOVWF  EECON2
089E:  MOVLW  AA
08A0:  MOVWF  EECON2
08A2:  BSF    EECON1.WR
08A4:  BTFSC  EECON1.WR
08A6:  BRA    08A4
08A8:  BCF    EECON1.WREN
08AA:  MOVF   @00,W
08AC:  IORWF  INTCON,F
....................           
....................          //store high byte in EEPROM just one location above f(a) 
....................          write_eeprom(f(a)+1,high_byte); 
08AE:  MOVFF  a,k
08B2:  MOVLB  0
08B4:  RCALL  018C
08B6:  MOVLW  01
08B8:  ADDWF  @01,W
08BA:  MOVLB  2
08BC:  MOVWF  @@xC0
08BE:  MOVFF  @@2C0,EEADR
08C2:  MOVFF  high_byte,EEDATA
08C6:  BCF    EECON1.CFGS
08C8:  BCF    EECON1.EEPGD
08CA:  BSF    EECON1.WREN
08CC:  MOVF   INTCON,W
08CE:  MOVWF  @00
08D0:  BCF    INTCON.GIE_GIEH
08D2:  MOVLB  F
08D4:  MOVLW  55
08D6:  MOVWF  EECON2
08D8:  MOVLW  AA
08DA:  MOVWF  EECON2
08DC:  BSF    EECON1.WR
08DE:  BTFSC  EECON1.WR
08E0:  BRA    08DE
08E2:  BCF    EECON1.WREN
08E4:  MOVF   @00,W
08E6:  IORWF  INTCON,F
....................        } 
08E8:  INCF   a,F
08EA:  MOVLB  2
08EC:  BRA    0840
....................    } 
....................  
....................    /* Read the 5 parameter values from EEPROM into array */ 
....................    // copy the values from EEPROM into data array that would be sent to master 
....................    for (a=0 ; a<5 ; a++) 
08EE:  CLRF   a
08F0:  MOVF   a,W
08F2:  SUBLW  04
08F4:  BTFSS  STATUS.C
08F6:  BRA    0A1C
....................       {   
....................          // copy low byte from EEPROM for every respective pointer 
....................          data[f(a)]=read_eeprom(f(a)); 
08F8:  MOVFF  a,k
08FC:  MOVLB  0
08FE:  RCALL  018C
0900:  MOVLW  data
0902:  ADDWF  @01,W
0904:  MOVWF  @01
0906:  CLRF   @03
0908:  BTFSC  STATUS.C
090A:  INCF   @03,F
090C:  MOVF   @01,W
090E:  MOVLB  2
0910:  MOVWF  @@xC0
0912:  MOVFF  03,@@2C1
0916:  MOVFF  a,k
091A:  MOVLB  0
091C:  RCALL  018C
091E:  MOVFF  01,@@2C2
0922:  MOVFF  INTCON,@@2C3
0926:  BCF    INTCON.GIE_GIEH
0928:  MOVFF  @@2C2,EEADR
092C:  BCF    EECON1.CFGS
092E:  BCF    EECON1.EEPGD
0930:  BSF    EECON1.RD
0932:  MOVF   EEDATA,W
0934:  MOVLB  2
0936:  BTFSC  @@xC3.7
0938:  BSF    INTCON.GIE_GIEH
093A:  MOVWF  @@xC2
093C:  MOVFF  @@2C1,FSR0H
0940:  MOVFF  @@2C0,FSR0L
0944:  MOVFF  @@2C2,INDF0
....................           
....................          // copy high byte from EEPROM for every respective pointer 
....................          data[f(a)+1]=read_eeprom(f(a)+1); 
0948:  MOVFF  a,k
094C:  MOVLB  0
094E:  RCALL  018C
0950:  MOVLW  01
0952:  ADDWF  @01,W
0954:  ADDLW  data
0956:  MOVWF  @01
0958:  CLRF   @03
095A:  BTFSC  STATUS.C
095C:  INCF   @03,F
095E:  MOVF   @01,W
0960:  MOVLB  2
0962:  MOVWF  @@xC0
0964:  MOVFF  03,@@2C1
0968:  MOVFF  a,k
096C:  MOVLB  0
096E:  RCALL  018C
0970:  MOVLW  01
0972:  ADDWF  @01,W
0974:  MOVLB  2
0976:  MOVWF  @@xC2
0978:  MOVFF  INTCON,@@2C3
097C:  BCF    INTCON.GIE_GIEH
097E:  MOVFF  @@2C2,EEADR
0982:  BCF    EECON1.CFGS
0984:  BCF    EECON1.EEPGD
0986:  BSF    EECON1.RD
0988:  MOVF   EEDATA,W
098A:  BTFSC  @@xC3.7
098C:  BSF    INTCON.GIE_GIEH
098E:  MOVWF  @@xC2
0990:  MOVFF  @@2C1,FSR0H
0994:  MOVFF  @@2C0,FSR0L
0998:  MOVFF  @@2C2,INDF0
....................           
....................          low_val=read_eeprom(f(a));      // copy low byte into 16 bit variable 
099C:  MOVFF  a,k
09A0:  MOVLB  0
09A2:  CALL   f
09A6:  MOVFF  01,@@2C0
09AA:  MOVFF  INTCON,@@2C1
09AE:  BCF    INTCON.GIE_GIEH
09B0:  MOVFF  @@2C0,EEADR
09B4:  BCF    EECON1.CFGS
09B6:  BCF    EECON1.EEPGD
09B8:  BSF    EECON1.RD
09BA:  MOVF   EEDATA,W
09BC:  MOVLB  2
09BE:  BTFSC  @@xC1.7
09C0:  BSF    INTCON.GIE_GIEH
09C2:  CLRF   low_val+1
09C4:  MOVWF  low_val
....................          high_val=read_eeprom(f(a)+1); // copy high byte into 16 bit variable 
09C6:  MOVFF  a,k
09CA:  MOVLB  0
09CC:  CALL   f
09D0:  MOVLW  01
09D2:  ADDWF  @01,W
09D4:  MOVLB  2
09D6:  MOVWF  @@xC0
09D8:  MOVFF  INTCON,@@2C1
09DC:  BCF    INTCON.GIE_GIEH
09DE:  MOVFF  @@2C0,EEADR
09E2:  BCF    EECON1.CFGS
09E4:  BCF    EECON1.EEPGD
09E6:  BSF    EECON1.RD
09E8:  MOVF   EEDATA,W
09EA:  BTFSC  @@xC1.7
09EC:  BSF    INTCON.GIE_GIEH
09EE:  CLRF   high_val+1
09F0:  MOVWF  high_val
....................          high_val=high_val<<8;   // shift high value to left 8 times 
09F2:  MOVFF  high_val,high_val+1
09F6:  CLRF   high_val
....................          value[a]=high_val | low_val; 
09F8:  BCF    STATUS.C
09FA:  RLCF   a,W
09FC:  CLRF   @03
09FE:  ADDLW  value
0A00:  MOVWF  FSR0L
0A02:  MOVLW  value>>8
0A04:  ADDWFC @03,W
0A06:  MOVWF  FSR0H
0A08:  MOVF   high_val,W
0A0A:  IORWF  low_val,W
0A0C:  MOVWF  @00
0A0E:  MOVF   high_val+1,W
0A10:  IORWF  low_val+1,W
0A12:  MOVFF  00,INDF0
0A16:  MOVWF  PREINC0
....................          // concatenate high and low bytes and store 16 bit variable in array 
....................       } 
0A18:  INCF   a,F
0A1A:  BRA    08F0
....................        
....................    a=0; // variable a is used as pointer for array elements in the whole program 
0A1C:  CLRF   a
....................     
.................... //********************** Main Loop that repeats forever **********************// 
....................    do 
....................    {  
....................       /* Following 4 lines read and display the voltage and current reading  
....................       that is received from master CPU */ 
....................    // concatenate lower and higher bytes of voltage value 
....................    voltage= make16(reading[1],reading[0]); 
0A1E:  MOVFF  reading+1,voltage+1
0A22:  MOVFF  reading,voltage
....................     
....................    // concatenate lower and higher bytes of current value 
....................    current= make16(reading[3],reading[2]); 
0A26:  MOVFF  reading+3,current+1
0A2A:  MOVFF  reading+2,current
....................     
....................    lcd_1_val=voltage;   // copy voltage to lcd 1 variable 
0A2E:  MOVFF  voltage+1,lcd_1_val+1
0A32:  MOVFF  voltage,lcd_1_val
....................    lcd_2_val=current;   // copy current to lcd 2 variable 
0A36:  MOVFF  current+1,lcd_2_val+1
0A3A:  MOVFF  current,lcd_2_val
....................    while(!input(SW4))         // Press once to enter menu 
....................    {  delay_ms(50);            // debouncing 
0A3E:  BSF    TRISB.3
0A40:  BTFSC  PORTB.3
0A42:  BRA    0C34
0A44:  MOVLW  32
0A46:  MOVWF  ??65535
0A48:  MOVLB  0
0A4A:  CALL   @delay_ms1
....................       while(!input(SW4));      //debouncing 
0A4E:  BSF    TRISB.3
0A50:  BTFSS  PORTB.3
0A52:  BRA    0A4E
....................       led_on(4); // indication for menu stage 0 ("show parameter" screen) 
0A54:  MOVLW  04
0A56:  MOVLB  2
0A58:  MOVWF  led
0A5A:  MOVLB  0
0A5C:  CALL   led_on
....................       show_parameters_mode=TRUE;  //set flag when show parameter screen is shown 
0A60:  BSF    show_parameters_mode
....................        
....................       // Clear Timer3 flag if interrupt has occured prior to being enabled 
....................       clear_interrupt(INT_TIMER3); 
0A62:  BCF    PIR2.TMR3IF
....................       enable_interrupts(INT_TIMER3); 
0A64:  BSF    PIE2.TMR3IE
....................       // enable timer for timeout monitoring and screen flash in edit screen 
....................        
....................       set_timer3(9286);    // set timer 3 to generate interrupt on every 90 ms 
0A66:  MOVLW  24
0A68:  MOVWF  TMR3H
0A6A:  MOVLW  46
0A6C:  MOVWF  TMR3L
....................       lcd_1_val=menu[a];      // hold parameter number for LCD1 
0A6E:  CLRF   @03
0A70:  MOVF   a,W
0A72:  ADDLW  menu
0A74:  MOVWF  FSR0L
0A76:  MOVLW  menu>>8
0A78:  ADDWFC @03,W
0A7A:  MOVWF  FSR0H
0A7C:  MOVF   INDF0,W
0A7E:  CLRF   @03
0A80:  MOVLB  2
0A82:  MOVWF  lcd_1_val
0A84:  MOVFF  03,lcd_1_val+1
....................       lcd_2_val=value[a];      // hold corresponding parameter value for LCD2 
0A88:  BCF    STATUS.C
0A8A:  RLCF   a,W
0A8C:  CLRF   @03
0A8E:  ADDLW  value
0A90:  MOVWF  FSR0L
0A92:  MOVLW  value>>8
0A94:  ADDWFC @03,W
0A96:  MOVWF  FSR0H
0A98:  MOVFF  PREINC0,03
0A9C:  MOVF   POSTDEC0,F
0A9E:  MOVFF  INDF0,lcd_2_val
0AA2:  MOVFF  03,lcd_2_val+1
....................       lcd_out(1,lcd_1_val);   // display lcd 1 value on LCD1    
0AA6:  MOVLW  01
0AA8:  MOVWF  n
0AAA:  MOVFF  lcd_1_val+1,val+1
0AAE:  MOVFF  lcd_1_val,val
0AB2:  MOVLB  0
0AB4:  CALL   lcd_out
....................       lcd_out(2,lcd_2_val);   // display lcd 2 value on LCD2 
0AB8:  MOVLW  02
0ABA:  MOVLB  2
0ABC:  MOVWF  n
0ABE:  MOVFF  lcd_2_val+1,val+1
0AC2:  MOVFF  lcd_2_val,val
0AC6:  MOVLB  0
0AC8:  CALL   lcd_out
....................       menu_timeout_monitor=0;  // reset timeout monitor 
0ACC:  CLRF   menu_timeout_monitor
....................        
....................       /* Select the parameter number to be shown through SW3 and SW2 */ 
....................       do 
....................       {                       
....................          while(!input(SW3))      // Press once to decrement parameter number 
....................          { 
0ACE:  BSF    TRISB.2
0AD0:  BTFSC  PORTB.2
0AD2:  BRA    0AF6
....................             while(!input(SW3));   // halt here until button is released 
0AD4:  BSF    TRISB.2
0AD6:  BTFSS  PORTB.2
0AD8:  BRA    0AD4
....................             delay_ms(50);         // delay to cater for bounce 
0ADA:  MOVLW  32
0ADC:  MOVLB  2
0ADE:  MOVWF  ??65535
0AE0:  MOVLB  0
0AE2:  CALL   @delay_ms1
....................             menu_timeout_monitor=0;      // reset tiemout monitor 
0AE6:  CLRF   menu_timeout_monitor
....................             if (a==0) a=4;      // underflow if a is already 0 
0AE8:  MOVF   a,F
0AEA:  BNZ   0AF2
0AEC:  MOVLW  04
0AEE:  MOVWF  a
....................             else a--;         // otherwise decrement once in a 
0AF0:  BRA    0AF4
0AF2:  DECF   a,F
....................          } 
0AF4:  BRA    0ACE
....................           
....................          while(!input(SW2))      // Press once to increment parameter number 
....................          { 
0AF6:  BSF    TRISB.1
0AF8:  BTFSC  PORTB.1
0AFA:  BRA    0B1E
....................             while(!input(SW2));    
0AFC:  BSF    TRISB.1
0AFE:  BTFSS  PORTB.1
0B00:  BRA    0AFC
....................             delay_ms(50); 
0B02:  MOVLW  32
0B04:  MOVLB  2
0B06:  MOVWF  ??65535
0B08:  MOVLB  0
0B0A:  CALL   @delay_ms1
....................             menu_timeout_monitor=0; 
0B0E:  CLRF   menu_timeout_monitor
....................             if (a==4) a=0;      // overflow if a is already 0 
0B10:  MOVF   a,W
0B12:  SUBLW  04
0B14:  BNZ   0B1A
0B16:  CLRF   a
....................             else a++;         // otherwise increment once in a 
0B18:  BRA    0B1C
0B1A:  INCF   a,F
....................          } 
0B1C:  BRA    0AF6
....................        
....................       lcd_1_val=menu[a];       
0B1E:  CLRF   @03
0B20:  MOVF   a,W
0B22:  ADDLW  menu
0B24:  MOVWF  FSR0L
0B26:  MOVLW  menu>>8
0B28:  ADDWFC @03,W
0B2A:  MOVWF  FSR0H
0B2C:  MOVF   INDF0,W
0B2E:  CLRF   @03
0B30:  MOVLB  2
0B32:  MOVWF  lcd_1_val
0B34:  MOVFF  03,lcd_1_val+1
....................       lcd_2_val=value[a]; 
0B38:  BCF    STATUS.C
0B3A:  RLCF   a,W
0B3C:  CLRF   @03
0B3E:  ADDLW  value
0B40:  MOVWF  FSR0L
0B42:  MOVLW  value>>8
0B44:  ADDWFC @03,W
0B46:  MOVWF  FSR0H
0B48:  MOVFF  PREINC0,03
0B4C:  MOVF   POSTDEC0,F
0B4E:  MOVFF  INDF0,lcd_2_val
0B52:  MOVFF  03,lcd_2_val+1
....................       lcd_out(1,lcd_1_val);      // Show updated parameter number 
0B56:  MOVLW  01
0B58:  MOVWF  n
0B5A:  MOVFF  lcd_1_val+1,val+1
0B5E:  MOVFF  lcd_1_val,val
0B62:  MOVLB  0
0B64:  CALL   lcd_out
....................       lcd_out(2,lcd_2_val);      // Show corresponding value on other LCD 
0B68:  MOVLW  02
0B6A:  MOVLB  2
0B6C:  MOVWF  n
0B6E:  MOVFF  lcd_2_val+1,val+1
0B72:  MOVFF  lcd_2_val,val
0B76:  MOVLB  0
0B78:  CALL   lcd_out
....................       
.................... /* Press SW4 to edit the parameter Value; store in EEPROM; send to Master CPU */ 
....................       while(!input(SW4))          
....................          {   
0B7C:  BSF    TRISB.3
0B7E:  BTFSC  PORTB.3
0B80:  BRA    0C12
....................          while(!input(SW4)); 
0B82:  BSF    TRISB.3
0B84:  BTFSS  PORTB.3
0B86:  BRA    0B82
....................             menu_timeout_monitor=0;   // reset timeout monitor 
0B88:  CLRF   menu_timeout_monitor
....................             temp_val=lcd_2_val;      // copy LCD 2 value in temporary variable. 
0B8A:  MOVFF  lcd_2_val+1,temp_val+1
0B8E:  MOVFF  lcd_2_val,temp_val
....................             edit_value(temp_val); 
0B92:  MOVFF  temp_val+1,lcdval+1
0B96:  MOVFF  temp_val,lcdval
0B9A:  BRA    0506
....................                // pass copy of temporary variable in edit value function 
....................              
....................             write_eeprom(f(a),low_byte); 
0B9C:  MOVFF  a,k
0BA0:  CALL   f
0BA4:  MOVFF  01,@@2C0
0BA8:  MOVFF  @@2C0,EEADR
0BAC:  MOVFF  low_byte,EEDATA
0BB0:  BCF    EECON1.CFGS
0BB2:  BCF    EECON1.EEPGD
0BB4:  BSF    EECON1.WREN
0BB6:  MOVF   INTCON,W
0BB8:  MOVWF  @00
0BBA:  BCF    INTCON.GIE_GIEH
0BBC:  MOVLB  F
0BBE:  MOVLW  55
0BC0:  MOVWF  EECON2
0BC2:  MOVLW  AA
0BC4:  MOVWF  EECON2
0BC6:  BSF    EECON1.WR
0BC8:  BTFSC  EECON1.WR
0BCA:  BRA    0BC8
0BCC:  BCF    EECON1.WREN
0BCE:  MOVF   @00,W
0BD0:  IORWF  INTCON,F
....................                /* store low byte on respective location in EEPROM after 
....................                 * returning from edit function */ 
....................              
....................             write_eeprom(f(a)+1,high_byte); 
0BD2:  MOVFF  a,k
0BD6:  MOVLB  0
0BD8:  CALL   f
0BDC:  MOVLW  01
0BDE:  ADDWF  @01,W
0BE0:  MOVLB  2
0BE2:  MOVWF  @@xC0
0BE4:  MOVFF  @@2C0,EEADR
0BE8:  MOVFF  high_byte,EEDATA
0BEC:  BCF    EECON1.CFGS
0BEE:  BCF    EECON1.EEPGD
0BF0:  BSF    EECON1.WREN
0BF2:  MOVF   INTCON,W
0BF4:  MOVWF  @00
0BF6:  BCF    INTCON.GIE_GIEH
0BF8:  MOVLB  F
0BFA:  MOVLW  55
0BFC:  MOVWF  EECON2
0BFE:  MOVLW  AA
0C00:  MOVWF  EECON2
0C02:  BSF    EECON1.WR
0C04:  BTFSC  EECON1.WR
0C06:  BRA    0C04
0C08:  BCF    EECON1.WREN
0C0A:  MOVF   @00,W
0C0C:  IORWF  INTCON,F
....................                /* store high byte on respective location in EEPROM after 
....................                 * returning from edit function */ 
....................          } // while(!input(SW4))    
0C0E:  MOVLB  0
0C10:  BRA    0B7C
....................  
....................       if(menu_timeout_monitor==56) break; 
0C12:  MOVF   menu_timeout_monitor,W
0C14:  SUBLW  38
0C16:  BNZ   0C1A
0C18:  BRA    0C20
....................        // if no button is pressed for 5.04 seconds then menu timeout will occur 
....................        
....................       } while(input(SW1));      // Press once to exit from menu 
0C1A:  BSF    TRISB.0
0C1C:  BTFSC  PORTB.0
0C1E:  BRA    0ACE
.................... /******************************************************************************/ 
....................       disable_interrupts(INT_TIMER3); 
0C20:  BCF    PIE2.TMR3IE
....................       // disable timer 3. there is no need of timeout or flashing on main screen 
....................        
....................       menu_timeout_monitor=0;      // reset timeout monitor 
0C22:  CLRF   menu_timeout_monitor
....................       show_parameters_mode=FALSE;   // clear flag for show parameters mode     
0C24:  BCF    show_parameters_mode
....................       led_off(4); 
0C26:  MOVLW  04
0C28:  MOVLB  2
0C2A:  MOVWF  led
0C2C:  MOVLB  0
0C2E:  RCALL  0470
....................       // led off to indicate an exit from menu stage 0 (show parameters screen) 
....................    } 
0C30:  MOVLB  2
0C32:  BRA    0A3E
.................... /******************************************************************************/ 
....................    /* get back to main screen and display voltage and current values 
....................     * that have been received in reading[] array from master CPU */ 
....................    lcd_out(1,lcd_1_val); 
0C34:  MOVLW  01
0C36:  MOVWF  n
0C38:  MOVFF  lcd_1_val+1,val+1
0C3C:  MOVFF  lcd_1_val,val
0C40:  MOVLB  0
0C42:  CALL   lcd_out
....................    lcd_out(2,lcd_2_val); 
0C46:  MOVLW  02
0C48:  MOVLB  2
0C4A:  MOVWF  n
0C4C:  MOVFF  lcd_2_val+1,val+1
0C50:  MOVFF  lcd_2_val,val
0C54:  MOVLB  0
0C56:  CALL   lcd_out
....................     
....................    }while(TRUE); 
.................... } 
0C5A:  MOVLB  2
0C5C:  BRA    0A1E
.................... /****************************** END OF FILE  **********************************/ 
0C5E:  BRA    0C5E

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV20 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0000   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
